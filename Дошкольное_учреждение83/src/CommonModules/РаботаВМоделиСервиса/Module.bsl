///////////////////////////////////////////////////////////////////////////////////
// РаботаВМоделиСервиса.
//
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Очищает все параметры сеанса, кроме связанных с общим 
// реквизитом ОбластьДанных.
//
Процедура ОчиститьВсеПараметрыСеансаКромеРазделителей() Экспорт
	
	ОбщегоНазначения.ОчиститьПараметрыСеанса(, "ОбластьДанныхЗначение,ОбластьДанныхИспользование");
	
КонецПроцедуры

// Устанавливает управляемую блокировку на пространства блокировок всех
// объектов, входящих в состав разделителя и неразделенные регистры сведений 
// хранящие разделенные данные (по текущему значению разделителя).
// Опционально проверяется наличие других пользовательских сеансов
// в текущей области данных.
// Может использоваться только в транзакции.
// Может использоваться только при включенном разделении и установленном
// значении разделителя.
// 
// Параметры: 
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// РазделяемаяБлокировка - Булеов - установить разделяемую блокировку
// вместо исключительной.
// 
Процедура ЗаблокироватьТекущуюОбластьДанных(Знач ПроверитьОтсутствиеДругихСеансов = Ложь, Знач РазделяемаяБлокировка = Ложь) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		ВызватьИсключение(НСтр("ru = 'Блокировка области может быть установлена только при включенном использовании разделителей'"));
	КонецЕсли;
	
	Если РазделяемаяБлокировка Тогда
		РежимБлокировки = РежимБлокировкиДанных.Разделяемый;
	Иначе
		РежимБлокировки = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	МДОбщегоРеквизита = Метаданные.ОбщиеРеквизиты.ОбластьДанных;
	
	// Константы
	Для каждого МетаданныеКонстанты Из Метаданные.Константы Цикл
		Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МетаданныеКонстанты) Тогда
			Продолжить;
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить(МетаданныеКонстанты.ПолноеИмя());
		ЭлементБлокировки.Режим = РежимБлокировки;
	КонецЦикла;
	
	// Ссылочные типы
	
	ВидыОбъектов = Новый Массив;
	ВидыОбъектов.Добавить("Справочники");
	ВидыОбъектов.Добавить("Документы");
	ВидыОбъектов.Добавить("ПланыВидовХарактеристик");
	ВидыОбъектов.Добавить("ПланыСчетов");
	ВидыОбъектов.Добавить("ПланыВидовРасчета");
	ВидыОбъектов.Добавить("БизнесПроцессы");
	ВидыОбъектов.Добавить("Задачи");
	ВидыОбъектов.Добавить("ПланыОбмена");
	
	Для каждого ВидОбъекта Из ВидыОбъектов Цикл
		МетаданныеКоллекция = Метаданные[ВидОбъекта];
		Для каждого МДОбъекта Из МетаданныеКоллекция Цикл
			Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДОбъекта) Тогда
				Продолжить;
			КонецЕсли;
			
			ЭлементБлокировки = Блокировка.Добавить(МДОбъекта.ПолноеИмя());
			ЭлементБлокировки.Режим = РежимБлокировки;
		КонецЦикла;
	КонецЦикла;
	
	// Регистры и последовательности
	ВидыТаблиц = Новый Массив;
	ВидыТаблиц.Добавить("РегистрыНакопления");
	ВидыТаблиц.Добавить("РегистрыРасчета");
	ВидыТаблиц.Добавить("РегистрыБухгалтерии");
	ВидыТаблиц.Добавить("РегистрыСведений");
	ВидыТаблиц.Добавить("Последовательности");
	Для каждого ВидТаблицы Из ВидыТаблиц Цикл
		МетаданныеКоллекция = Метаданные[ВидТаблицы];
		МенеджерВида = Вычислить(ВидТаблицы);
		Для каждого МДРегистра Из МетаданныеКоллекция Цикл
			Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДРегистра) Тогда
				Продолжить;
			КонецЕсли;
			
			БлокироватьНаборы = Истина;
			Если ВидТаблицы = "РегистрыСведений"
				И МДРегистра.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
				
				БлокироватьНаборы = Ложь;
			КонецЕсли;
			
			Если БлокироватьНаборы Тогда
				ЭлементБлокировки = Блокировка.Добавить(МДРегистра.ПолноеИмя() + ".НаборЗаписей");
			Иначе
				ЭлементБлокировки = Блокировка.Добавить(МДРегистра.ПолноеИмя());
			КонецЕсли;
			ЭлементБлокировки.Режим = РежимБлокировки;
			
			Если ВидТаблицы = "Последовательности" Тогда
				ЭлементБлокировки = Блокировка.Добавить(МДРегистра.ПолноеИмя() + ".Записи");
				ЭлементБлокировки.Режим = РежимБлокировки;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ЗначениеРазделителя = ОбщегоНазначения.ЗначениеРазделителяСеанса();
	
	// Планы обмен
	Для каждого МДОбъекта Из Метаданные.ПланыОбмена Цикл
		Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДОбъекта) Тогда
			Продолжить;
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить(МДОбъекта.ПолноеИмя());
		ЭлементБлокировки.Режим = РежимБлокировки;
	КонецЦикла;
	
	// Общие регистры сведений с разделенными данными
	ОбщиеРегистры = ОбщиеРегистрыСведенийСРазделеннымиДанными();
	
	Для каждого ИмяРегистра Из ОбщиеРегистры Цикл
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений." + ИмяРегистра);
		ЭлементБлокировки.УстановитьЗначение("ОбластьДанных", ЗначениеРазделителя);
		ЭлементБлокировки.Режим = РежимБлокировки;
	КонецЦикла;
	
	Блокировка.Заблокировать();
	
	Если ПроверитьОтсутствиеДругихСеансов Тогда
		Для каждого Сеанс Из ПолучитьСеансыИнформационнойБазы() Цикл
			Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
				Продолжить;
			КонецЕсли;
			
			КлиентскиеПриложения = Новый Массив;
			КлиентскиеПриложения.Добавить(ВРег("1CV8"));
			КлиентскиеПриложения.Добавить(ВРег("1CV8C"));
			КлиентскиеПриложения.Добавить(ВРег("WebClient"));
			КлиентскиеПриложения.Добавить(ВРег("COMConnection"));
			КлиентскиеПриложения.Добавить(ВРег("WSConnection"));
			КлиентскиеПриложения.Добавить(ВРег("BackgroundJob"));
			Если КлиентскиеПриложения.Найти(ВРег(Сеанс.ИмяПриложения)) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Есть другие пользователи
			ВызватьИсключение(НСтр("ru = 'Ошибка разделенного доступа к базе данных'"));
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает имена неразделенных регистров сведений, хранящих 
// разделенные (относящиеся к определенной области данных) данные
// 
// Возвращаемое значение: 
// Массив строк.
// Имена неразделенных регистров сведений с разделенными данными. 
// 
Функция ОбщиеРегистрыСведенийСРазделеннымиДанными() Экспорт
	
	ОбщиеРегистры = Новый Массив;
	
	СтандартныеПодсистемыПереопределяемый.ПолучитьОбщиеРегистрыСведенийСРазделеннымиДанными(ОбщиеРегистры);
	РаботаВМоделиСервисаПереопределяемый.ПолучитьОбщиеРегистрыСведенийСРазделеннымиДанными(ОбщиеРегистры);
	
	Возврат ОбщиеРегистры;
	
КонецФункции

// Подготавливает область данных к использованию. Запускает
// процедура обновления ИБ, при необходимости заполняет демонстрационными
// данными, устанавливает новый статус в регистре ОбластиДанных.
// 
// Параметры: 
// ОбластьДанных - Тип значения разделителя - значение разделителя
// области данных, которую необходимо подготовить к использованию.
// 
Процедура ПодготовитьОбластьДанныхКИспользованию(Знач ОбластьДанных, Знач ИДФайлаВыгрузки = Неопределено) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = РегистрыСведений.ОбластиДанных.СоздатьКлючЗаписи(Новый Структура("ОбластьДанных", ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("РегистрСведений.ОбластиДанных");
		Элемент.УстановитьЗначение("ОбластьДанных", ОбластьДанных);
		Элемент.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбластьДанных = ОбластьДанных;
		МенеджерЗаписи.Прочитать();
		
		Если НЕ МенеджерЗаписи.Выбран() Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не найдена'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		ИначеЕсли МенеджерЗаписи.Статус <> Перечисления.СтатусыОбластейДанных.Новая Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не является новой'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подготовка области данных'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьДанных);
	
	ПользователиСлужебный.АвторизоватьТекущегоПользователя();
	
	Если ИДФайлаВыгрузки <> Неопределено Тогда
		ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
		
		Если ИмяФайлаВыгрузки = Неопределено Тогда
			ВызватьИсключение(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Файл с id %1 не найден.'"), ИДФайлаВыгрузки));
		КонецЕсли;
		
		ВыгрузкаЗагрузкаДанных.ЗагрузитьТекущуюОбластьИзАрхива(ИмяФайлаВыгрузки);
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Подготовка области данных'"), 
				УровеньЖурналаРегистрации.Предупреждение, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
	Иначе
		Если Константы.РежимИспользованияИнформационнойБазы.Получить() = Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный
			ИЛИ Константы.КопироватьОбластиДанныхИзЭталонной.Получить() Тогда
			
			СкопироватьДанныеОбласти(0, ОбластьДанных);
		КонецЕсли;
	КонецЕсли;
	
	ОбновлениеИнформационнойБазы.ВыполнитьОбновлениеИнформационнойБазы(ИДФайлаВыгрузки <> Неопределено);
	
	МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Используется;
	
	// Отправить соообщение о готовности области в менеджер сервиса
	Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(
		РаботаВМоделиСервисаПовтИсп.СообщениеОбластьДанныхПодготовлена());
	Сообщение.Body.Zone = ОбластьДанных;
	
	НачатьТранзакцию();
	Попытка
		СообщенияВМоделиСервиса.ОтправитьСообщение(
			Сообщение,
			РаботаВМоделиСервисаПовтИсп.КонечнаяТочкаМенеджераСервиса());
		
		МенеджерЗаписи.Записать();
		
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Копирует данные области данных в другую область данных.
// 
// Параметры: 
// ОбластьИсточник - Тип значения разделителя - значение разделителя
// области данных - источника данных
// ОбластьПриемник - Тип значения разделителя - значение разделителя
// области данных - приемника данных
// 
Процедура СкопироватьДанныеОбласти(Знач ОбластьИсточник, Знач ОбластьПриемник) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьИсточник);
	
	ИмяФайлаВыгрузки = Неопределено;
	
	НачатьТранзакцию();
	Попытка
		ЗаблокироватьТекущуюОбластьДанных(, Истина);
		ИмяФайлаВыгрузки = ВыгрузкаЗагрузкаДанных.ВыгрузитьТекущуюОбластьВАрхив();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Копирование области данных'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ИмяФайлаВыгрузки <> Неопределено Тогда
			Попытка
				УдалитьФайлы(ИмяФайлаВыгрузки);
			Исключение
			КонецПопытки;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(, ОбластьПриемник);
	
	НачатьТранзакцию();
	Попытка
		ЗаблокироватьТекущуюОбластьДанных();
		ВыгрузкаЗагрузкаДанных.ЗагрузитьТекущуюОбластьИзАрхива(ИмяФайлаВыгрузки);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Копирование области данных'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

// Удаляет все данные области данных, кроме предопределенных.
// Так же удаляет пользователей области данных и данные неразделенных
// регистров сведений, относящиеся к области.
// 
// Параметры: 
// ОбластьДанных - Тип значения разделителя - значение разделителя
// области данных которую требуется очистить
//
Процедура ОчиститьОбластьДанных(Знач ОбластьДанных) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = РегистрыСведений.ОбластиДанных.СоздатьКлючЗаписи(Новый Структура("ОбластьДанных", ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
	
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("РегистрСведений.ОбластиДанных");
		Элемент.УстановитьЗначение("ОбластьДанных", ОбластьДанных);
		Элемент.Режим = РежимБлокировкиДанных.Разделяемый;
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбластьДанных = ОбластьДанных;
		
		Попытка
			НачатьТранзакцию();
			Блокировка.Заблокировать();
			
			МенеджерЗаписи.Прочитать();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если НЕ МенеджерЗаписи.Выбран() Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не найдена'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		ИначеЕсли МенеджерЗаписи.Статус <> Перечисления.СтатусыОбластейДанных.КУдалению Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не помечена к удалению'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
			
		ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьДанных);
		
		СтандартныеПодсистемыПереопределяемый.ПриУдаленииОбластиДанных(ОбластьДанных);
		РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных(ОбластьДанных);
		
		МДОбщегоРеквизита = Метаданные.ОбщиеРеквизиты.ОбластьДанных;
		
		// Переберем все метаданные
		
		// Константы
		Для каждого МетаданныеКонстанты Из Метаданные.Константы Цикл
			Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МетаданныеКонстанты) Тогда
				Продолжить;
			КонецЕсли;
			
			МенеджерЗначения = Константы[МетаданныеКонстанты.Имя].СоздатьМенеджерЗначения();
			МенеджерЗначения.ОбменДанными.Загрузка = Истина;
			МенеджерЗначения.Значение = МетаданныеКонстанты.Тип.ПривестиЗначение();
			МенеджерЗначения.Записать();
		КонецЦикла;
		
		// Ссылочные типы
		
		ВидыОбъектов = Новый Массив;
		ВидыОбъектов.Добавить("Справочники");
		ВидыОбъектов.Добавить("Документы");
		ВидыОбъектов.Добавить("ПланыВидовХарактеристик");
		ВидыОбъектов.Добавить("ПланыСчетов");
		ВидыОбъектов.Добавить("ПланыВидовРасчета");
		ВидыОбъектов.Добавить("БизнесПроцессы");
		ВидыОбъектов.Добавить("Задачи");
		
		Для каждого ВидОбъекта Из ВидыОбъектов Цикл
			МетаданныеКоллекция = Метаданные[ВидОбъекта];
			Для каждого МДОбъекта Из МетаданныеКоллекция Цикл
				Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДОбъекта) Тогда
					Продолжить;
				КонецЕсли;
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ
				|	_XMLВыгрузка_Таблица.Ссылка КАК Ссылка
				|ИЗ
				|	" + МДОбъекта.ПолноеИмя() + " КАК _XMLВыгрузка_Таблица";
				Если ВидОбъекта = "Справочники"
					ИЛИ ВидОбъекта = "ПланыВидовХарактеристик"
					ИЛИ ВидОбъекта = "ПланыСчетов"
					ИЛИ ВидОбъекта = "ПланыВидовРасчета" Тогда
					
					Запрос.Текст = Запрос.Текст + "
					|ГДЕ
					|	_XMLВыгрузка_Таблица.Предопределенный = ЛОЖЬ";
				КонецЕсли;
				
				РезультатЗапроса = Запрос.Выполнить();
				Выборка = РезультатЗапроса.Выбрать();
				Пока Выборка.Следующий() Цикл
					Удаление = Новый УдалениеОбъекта(Выборка.Ссылка);
					Удаление.ОбменДанными.Загрузка = Истина;
					Удаление.Записать();
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		// Регистры кроме независимых регистров сведений и последовательности
		ВидыТаблиц = Новый Массив;
		ВидыТаблиц.Добавить("РегистрыНакопления");
		ВидыТаблиц.Добавить("РегистрыРасчета");
		ВидыТаблиц.Добавить("РегистрыБухгалтерии");
		ВидыТаблиц.Добавить("РегистрыСведений");
		ВидыТаблиц.Добавить("Последовательности");
		Для каждого ВидТаблицы Из ВидыТаблиц Цикл
			МетаданныеКоллекция = Метаданные[ВидТаблицы];
			МенеджерВида = Вычислить(ВидТаблицы);
			Для каждого МДРегистра Из МетаданныеКоллекция Цикл
				Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДРегистра) Тогда
					Продолжить;
				КонецЕсли;
				
				Если ВидТаблицы = "РегистрыСведений"
					И МДРегистра.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
					
					Продолжить;
				КонецЕсли;
				
				МенеджерТипа = МенеджерВида[МДРегистра.Имя];
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ РАЗЛИЧНЫЕ
				|	_XMLВыгрузка_Таблица.Регистратор КАК Регистратор
				|ИЗ
				|	" + МДРегистра.ПолноеИмя() + " КАК _XMLВыгрузка_Таблица";
				РезультатЗапроса = Запрос.Выполнить();
				Выборка = РезультатЗапроса.Выбрать();
				Пока Выборка.Следующий() Цикл
					НаборЗаписей = МенеджерТипа.СоздатьНаборЗаписей();
					НаборЗаписей.Отбор.Регистратор.Установить(Выборка.Регистратор);
					НаборЗаписей.ОбменДанными.Загрузка = Истина;
					НаборЗаписей.Записать();
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		// Независимые регистры сведений
		Для каждого МДРегистра Из Метаданные.РегистрыСведений Цикл
			Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДРегистра) Тогда
				Продолжить;
			КонецЕсли;
			
			Если МДРегистра.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
				
				Продолжить;
			КонецЕсли;
			
			МенеджерТипа = РегистрыСведений[МДРегистра.Имя];
			
			НаборЗаписей = МенеджерТипа.СоздатьНаборЗаписей();
			НаборЗаписей.ОбменДанными.Загрузка = Истина;
			НаборЗаписей.Записать();
		КонецЦикла;
		
		// Планы обмена
		
		Для каждого МДПланаОбмена Из Метаданные.ПланыОбмена Цикл
			Если НЕ ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(МДПланаОбмена) Тогда
				Продолжить;
			КонецЕсли;
			
			МенеджерТипа = ПланыОбмена[МДПланаОбмена.Имя];
			
			Запрос = Новый Запрос;
			Запрос.Текст =
			"ВЫБРАТЬ
			|	_XMLВыгрузка_Таблица.Ссылка КАК Ссылка
			|ИЗ
			|	" + МДПланаОбмена.ПолноеИмя() + " КАК _XMLВыгрузка_Таблица
			|ГДЕ
			|	_XMLВыгрузка_Таблица.Ссылка <> &ЭтотУзел";
			Запрос.УстановитьПараметр("ЭтотУзел", МенеджерТипа.ЭтотУзел());
			РезультатЗапроса = Запрос.Выполнить();
			Выборка = РезультатЗапроса.Выбрать();
			Пока Выборка.Следующий() Цикл
				Удаление = Новый УдалениеОбъекта(Выборка.Ссылка);
				Удаление.ОбменДанными.Загрузка = Истина;
				Удаление.Записать();
			КонецЦикла;
		КонецЦикла;
		
		// Общие регистры сведений с разделенными данными
		ОбщиеРегистры = ОбщиеРегистрыСведенийСРазделеннымиДанными();
		
		Для каждого ИмяРегистра Из ОбщиеРегистры Цикл
			МенеджерТипа = РегистрыСведений[ИмяРегистра];
			
			НаборЗаписей = МенеджерТипа.СоздатьНаборЗаписей();
			НаборЗаписей.ОбменДанными.Загрузка = Истина;
			НаборЗаписей.Отбор.ОбластьДанных.Установить(ОбластьДанных);
			НаборЗаписей.Записать();
		КонецЦикла;
		
		// Пользователи
		Для каждого ПользовательИБ Из ПользователиИнформационнойБазы.ПолучитьПользователей() Цикл
			ПользовательИБ.Удалить();
		КонецЦикла;
		
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена;
		
		// Отправить соообщение об удалении области в менеджер сервиса
		Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(
			РаботаВМоделиСервисаПовтИсп.СообщениеОбластьДанныхУдалена());
		Сообщение.Body.Zone = ОбластьДанных;
			
		НачатьТранзакцию();
		Попытка
			СообщенияВМоделиСервиса.ОтправитьСообщение(
				Сообщение,
				РаботаВМоделиСервисаПовтИсп.КонечнаяТочкаМенеджераСервиса());
			
			МенеджерЗаписи.Записать();
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);
	
КонецПроцедуры

// Процедура одноименного регламентного задания.
// Находит все области данных со статусами, требующими обработки
// прикладным приложением и при необходимости планирует запуск ФЗ
// по их обслуживанию.
// 
Процедура ОбслуживаниеОбластейДанных() Экспорт
	
	МаксимальноеКоличествоПовторов = 3;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанных КАК ОбластьДанных,
	|	ОбластиДанных.Статус КАК Статус,
	|	ОбластиДанных.ИдентификаторВыгрузки КАК ИдентификаторВыгрузки
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Новая), ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.КУдалению))
	|	И ОбластиДанных.ОшибкаОбработки = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Выполняется = 0;
	
	Пока Выборка.Следующий() Цикл
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, Выборка.ОбластьДанных);
		
		Ключ = РегистрыСведений.ОбластиДанных.СоздатьКлючЗаписи(Новый Структура("ОбластьДанных", Выборка.ОбластьДанных));
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			Продолжить;
		КонецПопытки;
		
		Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанных = Выборка.ОбластьДанных;
		Менеджер.Прочитать();
		
		Если Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию";
		ИначеЕсли Менеджер.Статус = Перечисления.СтатусыОбластейДанных.КУдалению Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ОчиститьОбластьДанных";
		Иначе
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		Если Менеджер.Повтор < МаксимальноеКоличествоПовторов Тогда
		
			ОтборЗадания = Новый Структура;
			ОтборЗадания.Вставить("ИмяМетода", ИмяМетода);
			ОтборЗадания.Вставить("Ключ"     , "1");
			ЗапланированноеЗадание = ОчередьЗаданий.ПолучитьЗадание(ОтборЗадания, Выборка.ОбластьДанных);
			Если ЗапланированноеЗадание <> Неопределено Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Продолжить;
			КонецЕсли;
			
			Менеджер.Повтор = Менеджер.Повтор + 1;
			Менеджер.Записать();

			ПараметрыМетода = Новый Массив;
			ПараметрыМетода.Добавить(Выборка.ОбластьДанных);
			
			Если Выборка.Статус = Перечисления.СтатусыОбластейДанных.Новая
				И ЗначениеЗаполнено(Выборка.ИдентификаторВыгрузки) Тогда
				
				ПараметрыМетода.Добавить(Выборка.ИдентификаторВыгрузки);
			КонецЕсли;
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
			ОчередьЗаданий.ЗапланироватьВыполнениеЗадания(ИмяМетода, ПараметрыМетода, "1",, Выборка.ОбластьДанных);
		Иначе
			
			// Отправить соообщение о готовности области в менеджер сервиса
			Если Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда
				Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(
					РаботаВМоделиСервисаПовтИсп.СообщениеОшибкаПодготовкиОбластиДанных());
			Иначе
				Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(
					РаботаВМоделиСервисаПовтИсп.СообщениеОшибкаУдаленияОбластиДанных());
			КонецЕсли;
			Сообщение.Body.Zone = Менеджер.ОбластьДанных;
			Сообщение.Body.ErrorDescription = "";
			
			НачатьТранзакцию();
			Попытка
				Менеджер.ОшибкаОбработки = Истина;
				Менеджер.Записать();
				
				СообщенияВМоделиСервиса.ОтправитьСообщение(
					Сообщение,
					РаботаВМоделиСервисаПовтИсп.КонечнаяТочкаМенеджераСервиса());
					
				РазблокироватьДанныеДляРедактирования(Ключ);
					
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ВызватьИсключение;
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает прокси web-сервиса для синхронизации адинистративных действий в сервисе.
// 
// Возвращаемое значение: 
// WSПрокси.
// Прокси менеджера сервиса. 
// 
Функция ПолучитьПроксиМенеджераСервиса() Экспорт
	
	АдресМенеджераСервиса = Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	АдресСервиса = АдресМенеджераСервиса + "/ws/ManageApplication_1_0_2_1?wsdl";
	ИмяПользователя = Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить();
	ПарольПользователя = Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить();
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/ManageApplication/1.0.2.1",
		"ManageApplication_1_0_2_1", , ИмяПользователя, ПарольПользователя, 20);
		
	Возврат Прокси;
	
КонецФункции

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе
// ОбластьДанных - Число - Значение разделителя ОбластьДанных
//
Процедура УстановитьРазделениеСеанса(Знач Использование = Неопределено, Знач ОбластьДанных = Неопределено) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
		ВызватьИсключение(НСтр("ru = 'Изменить разделение сеанса возможно только из сеанса запущенного без указания разделителей'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Использование <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхИспользование = Использование;
	КонецЕсли;
	
	Если ОбластьДанных <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхЗначение = ОбластьДанных;
	КонецЕсли;
	
	СтандартныеПодсистемыПереопределяемый.ПриИзмененииОбластиДанных();
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		Если НЕ ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			ВызватьИсключение(НСтр("ru = 'Не установлено значение разделителя'"));
		КонецЕсли;
		
		// Получим значение разделителя текущей области данных
		УстановитьПривилегированныйРежим(Истина);
		Возврат ПараметрыСеанса.ОбластьДанныхЗначение;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат ПараметрыСеанса.ОбластьДанныхИспользование;
	
КонецФункции

// Добавляет дополнительные параметры в структуру параметров работы клиента
// при работе в модели сервиса.
//
// Параметры:
//  Параметры - Структура - структура параметров работы клиента
//
Процедура ДобавитьПараметрыРаботыКлиентаВМоделиСервиса(Знач Параметры) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДанных.Представление КАК Представление
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.ОбластьДанных = &ОбластьДанных";
	УстановитьПривилегированныйРежим(Истина);
	Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	Если НЕ Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если НЕ ПустаяСтрока(Выборка.Представление) Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", Выборка.Представление);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет описание параметра по имени константы в таблицу параметров.
// Возвращает добавленный параметр.
//
// Параметры: 
// ТаблицаПараметров - Таблица значений - таблица описания параметров ИБ
// ИмяКонстанты - Строка - имя константы, которую необходимо добавить в
// параметры ИБ
//
// Возвращаемое значение: 
// Строка таблицы значений.
// Строка содержащая описание добавленного параметра. 
// 
Функция ДобавитьКонстантуВТаблицуПараметровИБ(Знач ТаблицаПараметров, Знач ИмяКонстанты) Экспорт
	
	МетаданныеКонстанты = Метаданные.Константы[ИмяКонстанты];
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = МетаданныеКонстанты.Имя;
	СтрокаПараметра.Описание = МетаданныеКонстанты.Представление();
	СтрокаПараметра.Тип = МетаданныеКонстанты.Тип;
	
	Возврат СтрокаПараметра;
	
КонецФункции

// Возвращает таблицу описания параметров ИБ
//
// Возвращаемое значение: 
// Таблица значений.
// Таблица описывающая параметры ИБ.
// Колонки:
// Имя - Строка - имя параметра.
// Описание - Строка - описание параметра для отображения в пользовательском интерфейсе
// ЗапретЧтения - Булево - признак невозможности считывания параметра ИБ. Может установлен
//                         например для паролей.
// ЗапретЗаписи - Булево - признак невозможности изменения параметра ИБ.
// Тип - Описание типов - тип значения параметра. Допускается использовать только примитивные
//                         типы и перечисления присутствующие в управляющем приложении.
// 
Функция ПолучитьТаблицуПараметровИБ() Экспорт
	
	ТаблицаПараметров = ПолучитьПустуюТаблицуПараметровИБ();
	
	СтандартныеПодсистемыПереопределяемый.ПолучитьТаблицуПараметровИБ(ТаблицаПараметров);
	
	РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ(ТаблицаПараметров);
	
	Возврат ТаблицаПараметров;
	
КонецФункции

// Получает имя приложения, так как его задал Абонент.
//
// Возвращаемое значение - Строка - имя приложения.
//
Функция ПолучитьИмяПриложения() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ОбластиДанных.Представление
	               |ИЗ
	               |	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	               |ГДЕ
	               |	ОбластиДанных.ОбластьДанных = &ОбластьДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ПараметрыСеанса.ОбластьДанныхЗначение);
	
	ТаблицаОбластейДанных = Запрос.Выполнить().Выгрузить();
	
	Возврат ?(ТаблицаОбластейДанных.Количество() = 0, "", ТаблицаОбластейДанных.Получить(0).Получить(0));
	
КонецФункции

// Возвращает полный путь к каталогу временных файлов.
//
// Возвращаемое значение:
// Строка - Полный путь к каталогу временных файлов.
//
Функция ПолучитьОбщийКаталогВременныхФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИнформацияОСистеме = Новый СистемнаяИнформация;
	Если ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86
		ИЛИ ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		
		ОбщийВременныйКаталог = Константы.ОбщийКаталогВременныхФайловLinux.Получить();
		РазделительПути = "/";
	Иначе
		ОбщийВременныйКаталог = Константы.ОбщийКаталогВременныхФайлов.Получить();
		РазделительПути = "\";
	КонецЕсли;
	
	Если ПустаяСтрока(ОбщийВременныйКаталог) Тогда
		ОбщийВременныйКаталог = СокрЛП(КаталогВременныхФайлов());
	Иначе
		ОбщийВременныйКаталог = СокрЛП(ОбщийВременныйКаталог);
	КонецЕсли;
	
	Если Прав(ОбщийВременныйКаталог, 1) <> РазделительПути Тогда
		ОбщийВременныйКаталог = ОбщийВременныйКаталог + РазделительПути;
	КонецЕсли;
	
	Возврат ОбщийВременныйКаталог;
	
КонецФункции

// Возвращает размер блоков в Мб для передачи больших файлов частями.
//
Функция	ПолучитьРазмерБлокаПередачиФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РазмерБлокаПередачиФайла = Константы.РазмерБлокаПередачиФайла.Получить(); // Мб
	Если Не ЗначениеЗаполнено(РазмерБлокаПередачиФайла) Тогда
		РазмерБлокаПередачиФайла = 20;
	КонецЕсли;
	Возврат РазмерБлокаПередачиФайла;

КонецФункции

// Возвращает разделитель пути файловой системы в зависимости от типа платформы: Windows/Linux.
//
// Возвращаемое значение:
// Строка.
//
Функция ПолучитьРазделительПутиФайловойСистемы() Экспорт
	
	ИнформацияОСистеме = Новый СистемнаяИнформация;
	
	Если ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86
		ИЛИ ИнформацияОСистеме.ТипПлатформы = ТипПлатформы.Linux_x86_64 Тогда
		
		Возврат "/";
	Иначе
		Возврат "\";
	КонецЕсли;
	
КонецФункции

// Сериализует объект структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Строка - Сериализованное значение объекта структурного типа.
//
Функция ЗаписатьСтруктурныйОбъектXDTOВСтроку(Знач ЗначениеСтруктурногоТипа) Экспорт
	
	ОбъектXDTO = СтруктурныйОбъектВОбъектXDTO(ЗначениеСтруктурногоТипа);
	
	Возврат ЗаписатьЗначениеВСтроку(ОбъектXDTO);
	
КонецФункции

// Кодирует строковое значение по алгоритму base64
//
// Параметры:
// Строка - Строка.
//
// Возвращаемое значение:
// Строка - base64-представление.
//
Функция СтрокаВBase64(Знач Строка) Экспорт
	
	Хранилище = Новый ХранилищеЗначения(Строка, Новый СжатиеДанных(9));
	
	Возврат XMLСтрока(Хранилище);
	
КонецФункции

// Декодирует base64-представление строки в исходное значение.
//
// Параметры:
// СтрокаBase64 - Строка.
//
// Возвращаемое значение:
// Строка.
//
Функция Base64ВСтроку(Знач СтрокаBase64) Экспорт
	
	Хранилище = XMLЗначение(Тип("ХранилищеЗначения"), СтрокаBase64);
	
	Возврат Хранилище.Получить();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Возвращает полное имя файла, полученного из файлового хранилища МС по его идентификатору.
//
// Параметры:
// ИДФайла - УникальныйИдентификатор - Идентификатор файла в файловом хранилище МС.
//
// Возвращаемое значение:
// Строка - Полное имя извлеченного файла.
//
Функция ПолучитьФайлИзХранилищаМенеджераСервиса(Знач ИДФайла) Экспорт  
	
	АдресМенеджераСервиса = Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", АдресМенеджераСервиса);
	ПараметрыДоступаКХранилищу.Вставить("UserName", Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("Password", Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить());
	
	ОписаниеФайла = ПолучитьФайлИзХранилища(ИДФайла, ПараметрыДоступаКХранилищу, Истина);
	
	СвойстваФайла = Новый Файл(ОписаниеФайла.ПолноеИмя);
	Если Не СвойстваФайла.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СвойстваФайла.ПолноеИмя;           
		
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилищеМенеджераСервиса(Знач АдресДанныеФайл, Знач ИмяФайла = "") Экспорт
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", Константы.ВнутреннийАдресМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("UserName", Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить());
	ПараметрыДоступаКХранилищу.Вставить("Password", Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить());
	
	Возврат ПоместитьФайлВХранилище(АдресДанныеФайл, ПараметрыДоступаКХранилищу, ИмяФайла);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

////////////////////////////////////////////////////////////////////////////////
// Работа через Агента сервиса

// Для текущей ИБ удаляет заданные сеансы и разрывает соединения через Агент сервиса.
// Сеансы задаются своими номерами во входном массиве либо одним номером.
//
// Параметры:
//   СеансыКУдалению - Массив; Число - Числовой массив номеров сеансов или один номер сеанса.
//   ПараметрыАдминистрированияИБ - Структура с полями
// 	   ИмяАдминистратораИБ - Строка.
//	   ПарольАдминистратораИБ - Строка.
//	   ИмяАдминистратораКластера - Строка.
//	   ПарольАдминистратораКластера - Строка.
//	   ПортКластераСерверов - Число.
//	   ПортАгентаСервера - Число.
//
// Возвращаемое значение:
//   Булево - Истина, если успешно.
//
Функция УдалитьСеансыИРазорватьСоединенияЧерезАгентСервиса(Знач СеансыКУдалению, Знач ПараметрыАдминистрированияИБ) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	Если ТипЗнч(СеансыКУдалению) = Тип("Массив") Тогда
		СписокСеансов = СеансыКУдалению;
	ИначеЕсли ТипЗнч(СеансыКУдалению) = Тип("Число") Тогда
		СписокСеансов = Новый Массив;
		СписокСеансов.Добавить(СеансыКУдалению);
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип параметра ""СеансыКУдалению"".'"));
	КонецЕсли;
	
	Если СписокСеансов.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ПубликацияАгента = Константы.АдресАгентаСервиса.Получить();
	ПользовательАгента = Константы.ИмяПользователяАгентаСервиса.Получить();
	ПарольАгента = Константы.ПарольПользователяАгентаСервиса.Получить();
	
	// Проверить с помощью версионирования, поддерживается ли нужный интерфейс.
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПубликацияАгента,
		ПользовательАгента, ПарольАгента, "УправлениеАгентом");
		
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ВызватьИсключение(НСтр("ru = 'Агент сервиса. Выборочное удаление сеансов не поддерживается в этой версии.'"));
	КонецЕсли;
	
	// Сформировать XDTO-строку входных параметров для обращения к операциям сервиса.
	
	ЗначенияПараметров = Новый Структура;
	
	// Получить для текущей ИБ параметры соединения.
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	Если Не ПараметрыСоединения.Свойство("Srvr") Или Не ПараметрыСоединения.Свойство("Ref") Тогда
		ВызватьИсключение(НСтр("ru = 'Для файловой ИБ данная операция недоступна.'"));
	КонецЕсли;
	ЗначенияПараметров.Вставить("ИнформационнаяБаза", ПараметрыСоединения.Ref);
	
	ТипПараметрыАдминистрирования = ФабрикаXDTO.Тип("http://v8.1c.ru/agent/scripts/1.0", "ClusterAdministrationInfo");
	ПараметрыАдминистрированияКластера = ФабрикаXDTO.Создать(ТипПараметрыАдминистрирования);
	ПараметрыАдминистрированияКластера.AgentConnectionString = 
		"tcp://" + ПараметрыСоединения.Srvr + ":" 
		+ Формат(ПараметрыАдминистрированияИБ.ПортАгентаСервера, "ЧГ=");
	ПараметрыАдминистрированияКластера.ClusterPort = ПараметрыАдминистрированияИБ.ПортКластераСерверов;
	ПараметрыАдминистрированияКластера.ClusterUserName = ПараметрыАдминистрированияИБ.ИмяАдминистратораКластера;
	ПараметрыАдминистрированияКластера.ClusterPassword = СтрокаВBase64(ПараметрыАдминистрированияИБ.ПарольАдминистратораКластера);
	ПараметрыАдминистрированияКластера.IBUserName = ПараметрыАдминистрированияИБ.ИмяАдминистратораИБ;
	ПараметрыАдминистрированияКластера.IBPassword = СтрокаВBase64(ПараметрыАдминистрированияИБ.ПарольАдминистратораИБ);
	
	ЗначенияПараметров.Вставить("ПараметрыАдминистрированияКластера", ПараметрыАдминистрированияКластера);
	ЗначенияПараметров.Вставить("СписокСеансов", СписокСеансов);
	
	ПараметрыXDTO = ЗаписатьСтруктурныйОбъектXDTOВСтроку(ЗначенияПараметров);
	
	// Требуется поддержка 2-й версии, в которой реализовано выборочное удаление сеансов.
	
	Прокси = ОбщегоНазначения.WSПрокси(ПубликацияАгента + "/ws/ManageAgent_1_0_2_1?wsdl",
		"http://www.1c.ru/SaaS/1.0/WS",
		"ManageAgent_1_0_2_1",
		,
		ПользовательАгента,
		ПарольАгента,
		20);
		
	
	// Выполнить действие с помощью операции Web-сервиса.
	СостояниеЗавершения = Неопределено;
	Прокси.DoAction("УдалитьСеансыПоСписку", ПараметрыXDTO, СостояниеЗавершения);
	
	Возврат СостояниеЗавершения = "ДействиеВыполнено" Или СостояниеЗавершения = "Истина";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с параметрами ИБ

// Возвращает пустую таблицу параметров ИБ
//
Функция ПолучитьПустуюТаблицуПараметровИБ()
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("ЗапретЧтения", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗапретЗаписи", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Тип", Новый ОписаниеТипов("ОписаниеТипов"));
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Получает описание файла по его идентификатору в регистре Файлы.
// Если хранение на диске и ПутьВместоДанных = Истина, 
// в выходной структуре Данные = Неопределено, ПолноеИмя = Полное имя файла,
// иначе Данные - двоичные данные файла, ПолноеИмя - Неопределено.
// Значение ключа Имя всегда содержит имя в хранилище.
//
// Параметры:
// ИдентификаторФайла - УникальныйИдентификатор.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ПутьВместоДанных - Булево - Что возвращать. 
//		
// Возвращаемое значение:
// ОписаниеФайла - Структура:
//	Имя - Строка - имя файла в хранилище.
//	Данные - ДвоичныеДанные - данные файла.
//	ПолноеИмя - Строка - полное имя файла.
//			  - Файл будет удален автоматически по истечении срока хранения временных файлов.
//
Функция ПолучитьФайлИзХранилища(Знач ИдентификаторФайла, Знач ПараметрыПодключения, Знач ПутьВместоДанных = Ложь) Экспорт
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСССервера(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	
	Если ОбменЧерезФС Тогда
			
		Попытка
			ИмяФайла = ОписаниеПрокси.Прокси.WriteFileToFS(ИдентификаторФайла);
			СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = СвойстваФайла.Имя;
				
				Если ПутьВместоДанных Тогда
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = СвойстваФайла.ПолноеИмя;
				Иначе
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(СвойстваФайла.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					Попытка
						УдалитьФайлы(СвойстваФайла.ПолноеИмя);
					Исключение
					КонецПопытки;
				КонецЕсли;
				
				Возврат ОписаниеФайла;
			Иначе
				ОбменЧерезФС = Ложь;
			КонецЕсли;
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение файла из хранилища'"),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
			
	КонецЕсли; // ОбменЧерезФС
	
	КоличествоЧастей = Неопределено;
	ИмяФайлаВСправочнике = Неопределено;
	РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла();
	Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
		ИдентификаторПередачи = ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, КоличествоЧастей);
	Иначе
		ИдентификаторПередачи = Неопределено;
		ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, ИдентификаторПередачи, КоличествоЧастей);
	КонецЕсли;
	
	ИменаФайлов = Новый Массив;
	
	КаталогСборки = СоздатьКаталогСборки();
	
	Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, КоличествоЧастей);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	Иначе // 1-я версия.
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = Неопределено;
			ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеЧасти);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	КонецЕсли;
	ДанныеЧасти = Неопределено;
	
	ОписаниеПрокси.Прокси.ReleaseFile(ИдентификаторПередачи);

	ИмяАрхива = ПолучитьИмяВременногоФайла("zip");
	
	ОбъединитьФайлы(ИменаФайлов, ИмяАрхива);
	
	Разархиватор = Новый ЧтениеZipФайла(ИмяАрхива);
	Если Разархиватор.Элементы.Количество() > 1 Тогда
		ВызватьИсключение(НСтр("ru = 'В полученном архиве содержится более одного файла'"));
	КонецЕсли;
	
	ИмяФайла = КаталогСборки + Разархиватор.Элементы[0].Имя;
	Разархиватор.Извлечь(Разархиватор.Элементы[0], КаталогСборки);
	Разархиватор.Закрыть();
	
	ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
	ПереместитьФайл(ИмяФайла, ФайлРезультата.ПолноеИмя);
	
	ОписаниеФайла = СоздатьОписаниеФайла();
	ОписаниеФайла.Имя = ФайлРезультата.Имя;
	
	Если ПутьВместоДанных Тогда
		ОписаниеФайла.Данные = Неопределено;
		ОписаниеФайла.ПолноеИмя = ФайлРезультата.ПолноеИмя;
	Иначе
		ОписаниеФайла.Данные = Новый ДвоичныеДанные(ФайлРезультата.ПолноеИмя);
		ОписаниеФайла.ПолноеИмя = Неопределено;
		Попытка
			УдалитьФайлы(ФайлРезультата.ПолноеИмя);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяАрхива);
		УдалитьФайлы(КаталогСборки);
	Исключение
	КонецПопытки;
	
	Возврат ОписаниеФайла;
	
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилище(Знач АдресДанныеФайл, Знач ПараметрыПодключения, Знач ИмяФайла = "")
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	Описание = ПолучитьИмяФайлаСДанными(АдресДанныеФайл, ИмяФайла);
	СвойстваФайла = Новый Файл(Описание.Имя);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСНаСервер(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	Если ОбменЧерезФС Тогда
		
		// Сохранить данные в файл.
		ОбщийКаталог = ПолучитьОбщийКаталогВременныхФайлов();
		ЦелевойФайл = Новый Файл(ОбщийКаталог + СвойстваФайла.Имя);
		Если ЦелевойФайл.Существует() Тогда
			Если СвойстваФайла.ПолноеИмя = ЦелевойФайл.ПолноеИмя Тогда // Это один и тот же файл. Его можно, не передавая, сразу читать на сервере.
				Возврат ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
				// Нельзя удалять, поскольку он является и источником.
			КонецЕсли;
			// Источник и приемник - разные файлы. Чтобы не затереть чужой файл, делаем приемнику уникальное имя.
			НовыйИД = Новый УникальныйИдентификатор;
			ЦелевойФайл = Новый Файл(ОбщийКаталог + НовыйИД + СвойстваФайла.Расширение);
		КонецЕсли;
		
		Попытка
			Если Описание.Данные = Неопределено тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ЦелевойФайл.ПолноеИмя);
			Иначе
				Описание.Данные.Записать(ЦелевойФайл.ПолноеИмя);
			КонецЕсли;
			Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Добавление файла. Обмен через ФС'"),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
		
		УдалитьВременныеФайлы(ЦелевойФайл.ПолноеИмя);
		
	КонецЕсли; // ОбменЧерезФС
		
	Если Не ОбменЧерезФС Тогда
		
		РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла(); // Мб
		ИдентификаторПередачи = Новый УникальныйИдентификатор;
		
		// Сохранить данные в файл.
		КаталогСборки = СоздатьКаталогСборки();
		ПолноеИмяФайла = КаталогСборки + СвойстваФайла.Имя;
		
		Если Описание.Данные = Неопределено тогда
			Если СвойстваФайла.Существует() Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ПолноеИмяФайла);
			Иначе
				ВызватьИсключение(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Добавление файла в хранилище. Не найден файл %1.'"), СвойстваФайла.ПолноеИмя));
			КонецЕсли;
		Иначе
			Описание.Данные.Записать(ПолноеИмяФайла);
		КонецЕсли;
		
		// Архивировать файл.
		ИмяНеразделенногоФайла = ПолучитьИмяВременногоФайла("zip");
		Архиватор = Новый ЗаписьZipФайла(ИмяНеразделенногоФайла, , , , УровеньСжатияZIP.Минимальный);
		Архиватор.Добавить(ПолноеИмяФайла);
		Архиватор.Записать();
		
		// Разделить файл на части.
		ИменаФайлов = РазделитьФайл(ИмяНеразделенногоФайла, РазмерБлокаПередачиФайла * 1024 * 1024, КаталогСборки); // Мб => байты.
		
		Попытка
			УдалитьФайлы(ИмяНеразделенногоФайла);
		Исключение
		КонецПопытки;
		
		// Передать файл через сервис по частям.
		КоличествоЧастей = ИменаФайлов.Количество();
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла, КоличествоЧастей);
			КонецЦикла;
		Иначе // 1-я версия.
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла);
			КонецЦикла;
		КонецЕсли;
		
		Попытка
			УдалитьФайлы(КаталогСборки);
		Исключение
		КонецПопытки;
		
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Результат = ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей); 
		Иначе // 1-я версия.
			Результат = Неопределено;
			ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей, Результат); 
		КонецЕсли;
		
	КонецЕсли; // Не ОбменЧерезФС
	
	Возврат Результат;
	
КонецФункции	

// Возвращает структуру с именем и данными файла по адресу во временном хранилище/информации в объекте Файл/двоичным данным.
//
// Параметры:
//	АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес хранилища данных файла/Данные файла/Файл.
//	ИмяФайла - Строка.
//		
// Возвращаемое значение:
// Структура:
//   Данные - ДвоичныеДанные - Данные файла.
//   Имя - Строка - Имя файла.
//
Функция ПолучитьИмяФайлаСДанными(Знач АдресДанныеФайл, Знач ИмяФайла = "")
	
	Если ТипЗнч(АдресДанныеФайл) = Тип("Строка") Тогда // Адрес данных файла во временном хранилище.
		Если ПустаяСтрока(АдресДанныеФайл) Тогда
			ВызватьИсключение(НСтр("ru = 'Неверный адрес хранилища.'"));
		КонецЕсли;
		ДанныеФайла = ПолучитьИзВременногоХранилища(АдресДанныеФайл);
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("Файл") Тогда // Объект типа Файл.
		Если Не АдресДанныеФайл.Существует() Тогда
			ВызватьИсключение(НСтр("ru = 'Файл не найден.'"));
		КонецЕсли;
		ДанныеФайла = Неопределено;
		ИмяФайла = АдресДанныеФайл.ПолноеИмя;
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("ДвоичныеДанные") Тогда // Данные файла.
		ДанныеФайла = АдресДанныеФайл;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип данных'"));
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяФайла) Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	Возврат Новый Структура("Данные, Имя", ДанныеФайла, ИмяФайла);
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с сервера на клиент.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСССервера(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = Прокси.WriteTestFile();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = ПрочитатьПробныйФайл(ИмяФайла);
	
	Прокси.DeleteTestFile(ИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с клиента на сервер.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСНаСервер(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = ЗаписатьПробныйФайл();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Прокси.ReadTestFile(ИмяФайла);
	
	ПолноеИмяФайла = ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла;
	УдалитьВременныеФайлы(ПолноеИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Создать каталог с уникальным именем для размещения частей разделяемого файла.
//
// Возвращаемое значение:
// Строка - Имя каталога.
//
Функция СоздатьКаталогСборки()
	
	КаталогСборки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогСборки);
	Возврат КаталогСборки + ПолучитьРазделительПутиФайловойСистемы();
	
КонецФункции

// Читает тестовый файл с диска, сравнивая содержимое и имя: они должны совпадать.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// ИмяФайла - Строка - Без пути.
//
// Возвращаемое значение:
// Булево - Истина, если файл успешно прочтен и содержимое совпадает с его именем.
//
Функция ПрочитатьПробныйФайл(Знач ИмяФайла)
	
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
	Если СвойстваФайла.Существует() Тогда
		Текст = Новый ЧтениеТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
		ТестовыйИД = Текст.Прочитать();
		Текст.Закрыть();
		Возврат ТестовыйИД = СвойстваФайла.ИмяБезРасширения;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Записывает тестовый файл на диск, возвращая его имя и размер.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// РазмерФайла - Число.
//
// Возвращаемое значение:
// Строка - Имя пробного файла без пути.
//
Функция ЗаписатьПробныйФайл() Экспорт
	
	НовыйИД = Новый УникальныйИдентификатор;
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + НовыйИД + ".tmp");
	
	Текст = Новый ЗаписьТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
	Текст.Записать(НовыйИД);
	Текст.Закрыть();
	
	Возврат СвойстваФайла.Имя;
	
КонецФункции

// Создает незаполненную структуру нужного формата.
//
// Возвращаемое значение:
// Структура:
//   Имя - Строка - Имя файла в хранилище.
//   Данные - ДвоичныеДанные - Данные файла.
// 	 ПолноеИмя - Строка - Имя файла с путем.
//
Функция СоздатьОписаниеФайла()
	
	ОписаниеФайла = Новый Структура;
	ОписаниеФайла.Вставить("Имя");
	ОписаниеФайла.Вставить("Данные");
	ОписаниеФайла.Вставить("ПолноеИмя");
	ОписаниеФайла.Вставить("ОбязательныеПараметры", "Имя"); // Обязательные к заполнению параметры.
	Возврат ОписаниеФайла;
	
КонецФункции

// Получает объект WSПрокси Web-сервиса, заданного своим базовым именем.
//
// Параметры:
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// Возвращаемое значение:
//  Структура
//   Прокси - WSПрокси
//   ЕстьПоддержка2йВерсии - Булево
//
Функция ОписаниеПроксиСервисаПередачиФайлов(Знач ПараметрыПодключения)
	
	БазовоеИмяСервиса = "FilesTransfer";
	
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ЕстьПоддержка2йВерсии = Ложь;
		ВерсияИнтерфейса = "1.0.1.1"
	Иначе
		ЕстьПоддержка2йВерсии = Истина;
		ВерсияИнтерфейса = "1.0.2.1";
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		ПарольПользователя = ПараметрыПодключения.Password;
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	Если ВерсияИнтерфейса = Неопределено Или ВерсияИнтерфейса = "1.0.1.1" Тогда // 1-я версия.
		ИмяСервиса = БазовоеИмяСервиса;
	Иначе // Версии 2 и выше.
		ИмяСервиса = БазовоеИмяСервиса + "_" + СтрЗаменить(ВерсияИнтерфейса, ".", "_");
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("/ws/%1?wsdl", ИмяСервиса);
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, 
		"http://www.1c.ru/SaaS/1.0/WS", ИмяСервиса, , ИмяПользователя, ПарольПользователя, 600);
		
	Возврат Новый Структура("Прокси, ЕстьПоддержка2йВерсии", Прокси, ЕстьПоддержка2йВерсии);
		
КонецФункции

/////////////////////////////////////////////////////////////////////////////////
// Временные файлы

// Удалить файл(ы) на диске.
// Если в качестве имени файла задана маска с путем, разделить его на путь и маску.
//
Процедура УдалитьВременныеФайлы(Знач ИмяФайла)
	
	Попытка
		Если Прав(ИмяФайла, 1) = "*" Тогда // Маска.
			Индекс = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(
				ИмяФайла, ПолучитьРазделительПутиФайловойСистемы());
			Если Индекс > 0 Тогда
				ПутьКФайлу = Лев(ИмяФайла, Индекс - 1);
				МаскаФайла = Сред(ИмяФайла, Индекс + 1);
				Если НайтиФайлы(ПутьКФайлу, МаскаФайла, Ложь).Количество() > 0 Тогда
					УдалитьФайлы(ПутьКФайлу, МаскаФайла);
				КонецЕсли;
			КонецЕсли;
		Иначе
			СвойстваФайла = Новый Файл(ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				СвойстваФайла.УстановитьТолькоЧтение(Ложь); // Снять атрибут.
				УдалитьФайлы(СвойстваФайла.ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции удаления временного файла'"),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Сериализация

Функция ЗаписатьЗначениеВСтроку(Знач Значение)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	
	Если ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		ФабрикаXDTO.ЗаписатьXML(Запись, Значение, , , , НазначениеТипаXML.Явное);
	Иначе
		СериализаторXDTO.ЗаписатьXML(Запись, Значение, НазначениеТипаXML.Явное);
	КонецЕсли;
	
	Возврат Запись.Закрыть();
		
КонецФункции

// Отражает, является ли данный тип сериализуемым.
//
// Параметры:
// СтруктурныйТип - Тип.
//
// Возвращаемое значение:
// Булево.
//
Функция СериализуемыйСтруктурныйТип(СтруктурныйТип);
	
	МассивСериализуемыхТипов = РаботаВМоделиСервисаПовтИсп.СериализуемыеСтруктурныеТипы();
	
	Для Каждого СериализуемыйТип Из МассивСериализуемыхТипов Цикл 
		Если СтруктурныйТип = СериализуемыйТип Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
		
КонецФункции

// Получает XDTO-представление объекта структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Структурный объект XDTO - XDTO-представление объекта структурного типа.
//
Функция СтруктурныйОбъектВОбъектXDTO(Знач ЗначениеСтруктурногоТипа)
	
	СтруктурныйТип = ТипЗнч(ЗначениеСтруктурногоТипа);
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	XMLТипЗначения = СериализаторXDTO.XMLТипЗнч(ЗначениеСтруктурногоТипа);
	ТипСтруктура = ФабрикаXDTO.Тип(XMLТипЗначения);
	СтруктураXDTO = ФабрикаXDTO.Создать(ТипСтруктура);
	
	// Перебор допустимых структурных типов.
	
	Если СтруктурныйТип = Тип("Структура") Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		ТипСвойство = ТипСтруктура.Свойства.Получить("Property").Тип;
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			Свойство = ФабрикаXDTO.Создать(ТипСвойство);
			Свойство.name = КлючИЗначение.Ключ;
			Свойство.Value = ЗначениеТипаВЗначениеXDTO(КлючИЗначение.Значение);
			СтруктураXDTO.Property.Добавить(Свойство);
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		Для Каждого ЗначениеЭлемента Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.Value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеЭлемента));
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.pair.Добавить(СтруктурныйОбъектВОбъектXDTO(КлючИЗначение));
		КонецЦикла;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктураXDTO.key = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Ключ);
		СтруктураXDTO.value = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Значение);
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		XDTOТипКолонкаТЗ = ТипСтруктура.Свойства.Получить("column").Тип;
		
		Для Каждого Колонка Из ЗначениеСтруктурногоТипа.Колонки Цикл
			
			КолонкаXDTO = ФабрикаXDTO.Создать(XDTOТипКолонкаТЗ);
			
			КолонкаXDTO.Name = ЗначениеТипаВЗначениеXDTO(Колонка.Имя);
			КолонкаXDTO.ValueType = СериализаторXDTO.ЗаписатьXDTO(Колонка.ТипЗначения);
			КолонкаXDTO.Title = ЗначениеТипаВЗначениеXDTO(Колонка.Заголовок);
			КолонкаXDTO.Width = ЗначениеТипаВЗначениеXDTO(Колонка.Ширина);
			
			СтруктураXDTO.column.Добавить(КолонкаXDTO);
			
		КонецЦикла;
		
		XDTOТипИндексТЗ = ТипСтруктура.Свойства.Получить("index").Тип;
		
		Для Каждого Индекс Из ЗначениеСтруктурногоТипа.Индексы Цикл
			
			ИндексXDTO = ФабрикаXDTO.Создать(XDTOТипИндексТЗ);
			
			Для Каждого ПолеИндекса Из Индекс Цикл
				ИндексXDTO.column.Добавить(ЗначениеТипаВЗначениеXDTO(ПолеИндекса));
			КонецЦикла;
			
			СтруктураXDTO.index.Добавить(ИндексXDTO);
			
		КонецЦикла;
		
		XDTOТипСтрокаТЗ = ТипСтруктура.Свойства.Получить("row").Тип;
		
		Для Каждого СтрокаТЗ Из ЗначениеСтруктурногоТипа Цикл
			
			СтрокаXDTO = ФабрикаXDTO.Создать(XDTOТипСтрокаТЗ);
			
			Для Каждого ЗначениеКолонки Из СтрокаТЗ Цикл
				СтрокаXDTO.value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеКолонки));
			КонецЦикла;
			
			СтруктураXDTO.row.Добавить(СтрокаXDTO);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураXDTO;
	
КонецФункции

// Получает объект структурного типа из XDTO-объекта.
//
// Параметры:
// ОбъектXDTO - Объект XDTO.
//
// Возвращаемое значение:
// Структурный тип ( Массив, Структура, Соответствие или их фиксированные аналоги) 
//
Функция ОбъектXDTOВСтруктурныйОбъект(ОбъектXDTO)
	
	ТипДанныхXML = Новый ТипДанныхXML(ОбъектXDTO.Тип().Имя, ОбъектXDTO.Тип().UriПространстваИмен);
	Если ВозможностьЧтенияТипаДанныхXML(ТипДанныхXML) Тогда
		СтруктурныйТип = СериализаторXDTO.ИзXMLТипа(ТипДанныхXML);
	Иначе
		Возврат ОбъектXDTO;
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Строка") Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Структура")	Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктурныйОбъект = Новый Структура;
		
		Для Каждого Свойство Из ОбъектXDTO.Property Цикл
			СтруктурныйОбъект.Вставить(Свойство.name, ЗначениеXDTOВЗначениеТипа(Свойство.Value));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Структура") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированнаяСтруктура(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		СтруктурныйОбъект = Новый Массив;
		
		Для Каждого ЭлементМассива Из ОбъектXDTO.Value Цикл
			СтруктурныйОбъект.Добавить(ЗначениеXDTOВЗначениеТипа(ЭлементМассива));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Массив") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированныйМассив(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		СтруктурныйОбъект = Новый Соответствие;
		
		Для Каждого КлючИЗначениеXDTO Из ОбъектXDTO.pair Цикл
			КлючИЗначение = ОбъектXDTOВСтруктурныйОбъект(КлючИЗначениеXDTO);
			СтруктурныйОбъект.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Соответствие") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированноеСоответствие(СтруктурныйОбъект);
		КонецЕсли;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктурныйОбъект = Новый Структура("Ключ, Значение");
		СтруктурныйОбъект.Ключ = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.key);
		СтруктурныйОбъект.Значение = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.value);
		
		Возврат СтруктурныйОбъект;
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		СтруктурныйОбъект = Новый ТаблицаЗначений;
		
		Для Каждого Колонка Из ОбъектXDTO.column Цикл
			
			СтруктурныйОбъект.Колонки.Добавить(
				ЗначениеXDTOВЗначениеТипа(Колонка.Name), 
				СериализаторXDTO.ПрочитатьXDTO(Колонка.ValueType), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Title), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Width));
				
		КонецЦикла;
		Для Каждого Индекс Из ОбъектXDTO.index Цикл
			
			ИндексСтрокой = "";
			Для Каждого ПолеИндекса Из Индекс.column Цикл
				ИндексСтрокой = ИндексСтрокой + ПолеИндекса + ", ";
			КонецЦикла;
			ИндексСтрокой = СокрЛП(ИндексСтрокой);
			Если СтрДлина(ИндексСтрокой) > 0 Тогда
				ИндексСтрокой = Лев(ИндексСтрокой, СтрДлина(ИндексСтрокой) - 1);
			КонецЕсли;
			
			СтруктурныйОбъект.Индексы.Добавить(ИндексСтрокой);
		КонецЦикла;
		Для Каждого СтрокаXDTO Из ОбъектXDTO.row Цикл
			
			СтрокаТЗ = СтруктурныйОбъект.Добавить();
			
			ЧислоКолонок = СтруктурныйОбъект.Колонки.Количество();
			Для Индекс = 0 По ЧислоКолонок - 1 Цикл 
				СтрокаТЗ[СтруктурныйОбъект.Колонки[Индекс].Имя] = ЗначениеXDTOВЗначениеТипа(СтрокаXDTO.value[Индекс]);
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат СтруктурныйОбъект;
		
	КонецЕсли;
	
КонецФункции

Функция ВозможностьЧтенияТипаДанныхXML(Знач ТипДанныхXML)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьНачалоЭлемента("Dummy");
	Запись.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	Запись.ЗаписатьСоответствиеПространстваИмен("ns1", ТипДанныхXML.URIПространстваИмен);
	Запись.ЗаписатьАтрибут("xsi:type", "ns1:" + ТипДанныхXML.ИмяТипа);
	Запись.ЗаписатьКонецЭлемента();
	
	Строка = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Строка);
	Чтение.ПерейтиКСодержимому();
	
	Возврат СериализаторXDTO.ВозможностьЧтенияXML(Чтение);
	
КонецФункции

// Получает значение простейшего типа в контексте XDTO.
//
// Параметры:
// ЗначениеТипа - Значение произвольного типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеТипаВЗначениеXDTO(Знач ЗначениеТипа)
	
	Если ЗначениеТипа = Неопределено
		Или ТипЗнч(ЗначениеТипа) = Тип("ОбъектXDTO")
		Или ТипЗнч(ЗначениеТипа) = Тип("ЗначениеXDTO") Тогда
		
		Возврат ЗначениеТипа;
		
	Иначе
		
		Если ТипЗнч(ЗначениеТипа) = Тип("Строка") Тогда
			ТипXDTO = ФабрикаXDTO.Тип("http://www.w3.org/2001/XMLSchema", "string")
		Иначе
			ТипXML = СериализаторXDTO.XMLТипЗнч(ЗначениеТипа);
			ТипXDTO = ФабрикаXDTO.Тип(ТипXML);
		КонецЕсли;
		
		Если ТипЗнч(ТипXDTO) = Тип("ТипОбъектаXDTO") Тогда // Значение структурного типа.
			Возврат СтруктурныйОбъектВОбъектXDTO(ЗначениеТипа);
		Иначе
			Возврат ФабрикаXDTO.Создать(ТипXDTO, ЗначениеТипа); // Например, UUID.
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Получает платформенный аналог значения XDTO-типа.
//
// Параметры:
// ЗначениеXDTO - Значение произвольного XDTO-типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеXDTOВЗначениеТипа(ЗначениеXDTO)
	
	Если ТипЗнч(ЗначениеXDTO) = Тип("ЗначениеXDTO") Тогда
		Возврат ЗначениеXDTO.Значение;
	ИначеЕсли ТипЗнч(ЗначениеXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат ОбъектXDTOВСтруктурныйОбъект(ЗначениеXDTO);
	Иначе
		Возврат ЗначениеXDTO;
	КонецЕсли;
	
КонецФункции
