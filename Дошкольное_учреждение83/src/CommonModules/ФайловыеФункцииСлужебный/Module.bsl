////////////////////////////////////////////////////////////////////////////////
// Подсистема "Файловые функции".
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации. 
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ДобавитьПараметрыРаботыКлиента(Параметры) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Параметры.Вставить("ПерсональныеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		ФайловыеФункцииСлужебныйПовтИсп.ПолучитьПерсональныеНастройкиРаботыСФайлами()));
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Извлекает текст из файлов на диске
Процедура ИзвлечениеТекста() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если НЕ ЭтоПлатформаWindows() Тогда
		Возврат; // извлечение текста работает только под Windows
	КонецЕсли;
	
	ИмяСРасширениемФайла = "";
	
	ЗаписьЖурналаРегистрации("Извлечение текста",
			УровеньЖурналаРегистрации.Информация, , ,
			НСтр("ru = 'Начато регламентное извлечение текста'"));
		
	ТекстЗапроса = Неопределено;
	СтандартныеПодсистемыПереопределяемый.ПолучитьТекстЗапросаДляИзвлеченияТекста(ТекстЗапроса);
	Запрос = Новый Запрос(ТекстЗапроса);
	Результат = Запрос.Выполнить();
	
	ТаблицаВыгрузки = Результат.Выгрузить();
	
	Для Каждого Строка Из ТаблицаВыгрузки Цикл
		
		ФайлОбъект = Строка.Ссылка.ПолучитьОбъект();
		Попытка
			ФайлОбъект.Заблокировать();
		Исключение
			// если файл уже заблокирован - не обрабатываем его
			Продолжить;
		КонецПопытки;
		
		ИмяСРасширениемФайла = ФайлОбъект.Наименование + "." + ФайлОбъект.Расширение;
		ИмяФайлаСПутем = "";
		
		ИмяФайлаСПутем = СтандартныеПодсистемыПереопределяемый.ПолучитьИмяФайлаСПутемКДвоичнымДанным(
			ФайлОбъект.Ссылка);
		
		Если ПустаяСтрока(ИмяФайлаСПутем) Тогда
			Продолжить;
		КонецЕсли;
		
		Кодировка = ПолучитьКодировкуВерсииФайла(Строка.Ссылка);
		
		Отказ = Ложь;
		Текст = ФайловыеФункцииСлужебныйКлиентСервер.ИзвлечьТекст(ИмяФайлаСПутем, Отказ, Кодировка);
		
		Если Отказ = Ложь Тогда
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		Иначе	
			// Ничего не пишем в журнал регистрации - это нормальная ситуация - когда Текст некому извлечь
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
		КонецЕсли;	
			
		Если Строка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			УдалитьФайлы(ИмяФайлаСПутем);
		КонецЕсли;
		
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст, Новый СжатиеДанных);
		
		Попытка
			СтандартныеПодсистемыПереопределяемый.ЗаписатьИзвлеченныйТекст(ФайлОбъект);
		Исключение
			
			ОписаниеОшибкиИнфо = ОписаниеОшибки();
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
									НСтр("ru = 'Во время регламентного извлечения текста из файла ""%1"" произошла неизвестная ошибка.'"), 
									ИмяСРасширениемФайла);
			ТекстСообщения = ТекстСообщения + Строка(ОписаниеОшибкиИнфо);
			
			ЗаписьЖурналаРегистрации("Извлечение текста",
				УровеньЖурналаРегистрации.Ошибка, , ,
				ТекстСообщения);
			
		КонецПопытки;
		
	КонецЦикла;
		
	ЗаписьЖурналаРегистрации("Извлечение текста", 
		УровеньЖурналаРегистрации.Информация, , ,
		НСтр("ru = 'Закончено регламентное извлечение текста'"));
	
КонецПроцедуры

// Получает строку из временного хранилища (передача с клиента на сервер,
// делается через временное хранилище)
//
Функция ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста) Экспорт
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ПолучитьИзВременногоХранилища(АдресВременногоХранилищаТекста).Записать(ИмяВременногоФайла);
	
	ТекстовыйФайл = Новый ЧтениеТекста(ИмяВременногоФайла, КодировкаТекста.UTF8);
	Текст = ТекстовыйФайл.Прочитать();
	ТекстовыйФайл.Закрыть();
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат Текст;
	
КонецФункции

// Возвращает максимальный размер файла
//
Функция ПолучитьМаксимальныйРазмерФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МаксимальныйРазмерФайла = Константы.МаксимальныйРазмерФайла.Получить();
	Если МаксимальныйРазмерФайла = Неопределено ИЛИ МаксимальныйРазмерФайла = 0 Тогда
		МаксимальныйРазмерФайла = 50*1024*1024; // 50 мб
		Константы.МаксимальныйРазмерФайла.Установить(МаксимальныйРазмерФайла);
	КонецЕсли;
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		МаксимальныйРазмерФайлаОбластиДанных = Константы.МаксимальныйРазмерФайлаОбластиДанных.Получить();
		
		Если МаксимальныйРазмерФайлаОбластиДанных = Неопределено ИЛИ МаксимальныйРазмерФайлаОбластиДанных = 0 Тогда
			МаксимальныйРазмерФайлаОбластиДанных = 50*1024*1024; // 50 мб
			Константы.МаксимальныйРазмерФайлаОбластиДанных.Установить(МаксимальныйРазмерФайлаОбластиДанных);
		КонецЕсли;
		
		МаксимальныйРазмерФайла = Мин(МаксимальныйРазмерФайла, МаксимальныйРазмерФайлаОбластиДанных);
		
	КонецЕсли;
	
	Возврат МаксимальныйРазмерФайла;
	
КонецФункции

// Возвращает максимальный размер файла провайдера
//
Функция ПолучитьМаксимальныйРазмерФайлаОбщий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МаксимальныйРазмерФайла = Константы.МаксимальныйРазмерФайла.Получить();
	Если МаксимальныйРазмерФайла = Неопределено ИЛИ МаксимальныйРазмерФайла = 0 Тогда
		МаксимальныйРазмерФайла = 50*1024*1024; // 50 мб
		Константы.МаксимальныйРазмерФайла.Установить(МаксимальныйРазмерФайла);
	КонецЕсли;
	
	Возврат МаксимальныйРазмерФайла;
	
КонецФункции

// Возвращает значение константы ИзвлекатьТекстыФайловНаСервере
Функция ФоновоеИзвлечениеТекстовФайловНаСервере() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ИзвлекатьТекстыФайловНаСервере.Получить();
	
КонецФункции

// Возвращает Истина, если сервер работает под Windows
Функция ЭтоПлатформаWindows() Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
	 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Записывает на сервер результат извлечения текста - извлеченный текст и СтатусИзвлеченияТекста
Процедура ЗаписатьРезультатИзвлеченияТекста(ФайлИлиВерсияСсылка, РезультатИзвлечения, АдресВременногоХранилищаТекста) Экспорт
	
	ФайлИлиВерсияОбъект = ФайлИлиВерсияСсылка.ПолучитьОбъект();
	ФайлИлиВерсияОбъект.Заблокировать();
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Текст = "";
	Иначе
		Текст = ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		ФайлИлиВерсияОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		УдалитьИзВременногоХранилища(АдресВременногоХранилищаТекста);
	КонецЕсли;
	
	Если РезультатИзвлечения = "НеИзвлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	ИначеЕсли РезультатИзвлечения = "Извлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
	ИначеЕсли РезультатИзвлечения = "ИзвлечьНеУдалось" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
	КонецЕсли;
	
	СтандартныеПодсистемыПереопределяемый.ЗаписатьИзвлеченныйТекст(ФайлИлиВерсияОбъект);
	
КонецПроцедуры

// Возвращает ЗапрещатьЗагрузкуФайловПоРасширению
Функция ПолучитьЗапретЗагрузкиФайловПоРасширению() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ЗапретЗагрузкиФайловПоРасширению = Константы.ЗапрещатьЗагрузкуФайловПоРасширению.Получить();
	Возврат ЗапретЗагрузкиФайловПоРасширению;
	
КонецФункции

// Возвращает СписокЗапрещенныхРасширений
Функция ПолучитьСписокЗапрещенныхРасширений() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СписокЗапрещенныхРасширенийОбластиДанных = Константы.СписокЗапрещенныхРасширенийОбластиДанных.Получить();
	Если СписокЗапрещенныхРасширенийОбластиДанных = Неопределено ИЛИ СписокЗапрещенныхРасширенийОбластиДанных = "" Тогда
		СписокЗапрещенныхРасширенийОбластиДанных = "COM EXE BAT CMD VBS VBE JS JSE WSF WSH SCR";
		Константы.СписокЗапрещенныхРасширенийОбластиДанных.Установить(СписокЗапрещенныхРасширенийОбластиДанных);
	КонецЕсли;
	
	ИтоговыйСписокРасширений = "";
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		СписокЗапрещенныхРасширений = Константы.СписокЗапрещенныхРасширений.Получить();
		ИтоговыйСписокРасширений = СписокЗапрещенныхРасширений + " "  + СписокЗапрещенныхРасширенийОбластиДанных;
	Иначе	
	    ИтоговыйСписокРасширений = СписокЗапрещенныхРасширенийОбластиДанных;
	КонецЕсли;	
		
	Возврат ИтоговыйСписокРасширений;    
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с томами файлов

// Добавляет файл в один из томов (где есть свободное место)
//
Процедура ДобавитьНаДиск(
		ДвоичныеДанные,
		ПутьКФайлуВТоме,
		СсылкаНаТом,
		ВремяИзменения,
		НомерВерсии,
		ИмяБезРасширения,
		Расширение,
		РазмерФайла = 0,
		Зашифрован = Ложь,
		ДатаДляРазмещенияВТоме = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СсылкаНаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	
	ОписаниеВсехОшибок = ""; // здесь соберем ошибки со всех томов
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ТомаХраненияФайлов.Ссылка
		|ИЗ
		|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
		|ГДЕ
		|	ТомаХраненияФайлов.ПометкаУдаления = &ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТомаХраненияФайлов.ПорядокЗаполнения";

	Запрос.УстановитьПараметр("ПометкаУдаления", Ложь);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Количество() = 0 Тогда
		ВызватьИсключение(НСтр("ru = 'Нет ни одного тома для размещения файла.'"));
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		
		СсылкаНаТом = Выборка.Ссылка;
		
		ПутьКТому = ПолныйПутьТома(СсылкаНаТом);
		// Добавляем слэш в конце, если его нет.
		ПутьКТому = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(
			ПутьКТому, ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
		
		// Имя файла для хранения на диске формировать следующим образом
		// - имя файла.номер версии.расширение файла.
		Если ПустаяСтрока(НомерВерсии) Тогда
			ИмяФайла = ИмяБезРасширения + "." + Расширение;
		Иначе
			ИмяФайла = ИмяБезРасширения + "." + НомерВерсии + "." + Расширение;
		КонецЕсли;
		
		Если Зашифрован Тогда
			ИмяФайла = ИмяФайла + "." + "p7m";
		КонецЕсли;
		
		Попытка
			
			// Если МаксимальныйРазмер = 0 - нет ограничения на размер файлов на томе.
			Если СсылкаНаТом.МаксимальныйРазмер <> 0 Тогда
				
				ТекущийРазмерВБайтах = 0;
				
				СтандартныеПодсистемыПереопределяемый.ПодсчитатьРазмерФайловНаТоме(
					СсылкаНаТом.Ссылка, ТекущийРазмерВБайтах);
				
				НовыйРазмерВБайтах = ТекущийРазмерВБайтах + РазмерФайла;
				НовыйРазмер = НовыйРазмерВБайтах / (1024 * 1024);
				
				Если НовыйРазмер > СсылкаНаТом.МаксимальныйРазмер Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Превышен максимальный размер тома (%1 Мб).'"),
						СсылкаНаТом.МаксимальныйРазмер);
				КонецЕсли;
			КонецЕсли;
			
			Дата = ТекущаяДатаСеанса();
			Если ДатаДляРазмещенияВТоме <> Неопределено Тогда
				Дата = ДатаДляРазмещенияВТоме;
			КонецЕсли;	
			
			ПутьДня = Формат(Дата, "ДФ=ггггММдд") + ФайловыеФункцииСлужебныйКлиентСервер.ПолучитьСлеш(ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
			ПутьКТому = ПутьКТому + ПутьДня;
			
			ИмяФайлаСПутем = ФайловыеФункцииСлужебныйКлиентСервер.ПолучитьУникальноеИмяСПутем(ПутьКТому, ИмяФайла, ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
			ПолноеИмяФайлаСПутем = ПутьКТому + ИмяФайлаСПутем;
			
			Если ТипЗнч(ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
				ДвоичныеДанные.Записать(ПолноеИмяФайлаСПутем);
			ИначеЕсли ТипЗнч(ДвоичныеДанные) = Тип("Строка") Тогда // считаем, что иначе это путь к файлу на диске
				КопироватьФайл(ДвоичныеДанные, ПолноеИмяФайлаСПутем);
			Иначе
				СтрокаИсключения = НСтр("ru = 'Неверный тип данных для добавления на том'");
				ВызватьИсключение(СтрокаИсключения);
			КонецЕсли;
			
			// Установим время изменения файла таким, как оно стоит в текущей версии
			ФайлНаДиске = Новый Файл(ПолноеИмяФайлаСПутем);
			ФайлНаДиске.УстановитьВремяИзменения(ВремяИзменения);
			ФайлНаДиске.УстановитьТолькоЧтение(Истина);
			
			ПутьКФайлуВТоме = ПутьДня + ИмяФайлаСПутем;
			Возврат; // закончили - выйдем из процедуры
			
		Исключение
			Если ОписаниеВсехОшибок <> "" Тогда
				ОписаниеВсехОшибок = ОписаниеВсехОшибок + Символы.ПС + Символы.ПС;
			КонецЕсли;
			
			ОписаниеВсехОшибок = ОписаниеВсехОшибок + НСтр("ru = 'Ошибка при добавлении файла на том: '");
			ОписаниеВсехОшибок = ОписаниеВсехОшибок + СсылкаНаТом;
			ОписаниеВсехОшибок = ОписаниеВсехОшибок + " (" + ПутьКТому + "): ";
			ОписаниеВсехОшибок = ОписаниеВсехОшибок + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
			Если СсылкаНаТом.ПолныйПутьLinux = СсылкаНаТом.ПолныйПутьWindows Тогда
				ОписаниеВсехОшибок = ОписаниеВсехОшибок + Символы.ПС;
				ОписаниеВсехОшибок = ОписаниеВсехОшибок + НСтр("ru = 'Настройте полный путь к тому.'");
			КонецЕсли;
			// надо переходить к следующему тому
			Продолжить;
		КонецПопытки;
		
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// запись в журнал регистрации для администратора
	// здесь выдадим ошибки со всех томов
	СообщениеОбОшибке = НСтр("ru = 'Не удалось добавить файл ни на один из томов. Список ошибок: '") + Символы.ПС + Символы.ПС + ОписаниеВсехОшибок;
	ЗаписьЖурналаРегистрации("Добавление файла", УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
	
	// здесь сообщение пользователю
	СтрокаИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			 НСтр("ru = 'Не удалось добавить файл: ""%1.%2"". Обратитесь к администратору системы.'"),
			 ИмяБезРасширения, Расширение);
			 
	Если Пользователи.ЭтоПолноправныйПользователь() Тогда
		СтрокаИсключения = СообщениеОбОшибке;	
	КонецЕсли;	 
	ВызватьИсключение СтрокаИсключения;

КонецПроцедуры

// Возвращает полный путь тома - в зависимости от ОС
Функция ПолныйПутьТома(СсылкаНаТом) Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		Возврат СсылкаНаТом.ПолныйПутьWindows;
	Иначе	
		Возврат СсылкаНаТом.ПолныйПутьLinux;
	КонецЕсли;
	
КонецФункции

//Есть ли хоть один том хранения файлов.
Функция ЕстьТомаХраненияФайлов() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК Поле1
	|ИЗ
	|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
	|ГДЕ
	|	ТомаХраненияФайлов.ПометкаУдаления = ЛОЖЬ";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Получает хранение файлов в томах
//
Функция ПолучитьКонстантуХранитьФайлыВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	Возврат ХранитьФайлыВТомахНаДиске;
	
КонецФункции

// Получает тип хранения файлов
//
Функция ПолучитьХранитьФайлыВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	Возврат ХранитьФайлыВТомахНаДиске;
	
КонецФункции

// Получает тип хранения файлов как перечисление
//
Функция ПолучитьТипХраненияФайлов() Экспорт
	
	ХранитьФайлыВТомахНаДиске = ПолучитьХранитьФайлыВТомахНаДиске();
	
	Если ХранитьФайлыВТомахНаДиске Тогда
		
		Если ЕстьТомаХраненияФайлов() Тогда
			Возврат Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
		Иначе
			Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
		КонецЕсли;		
		
	Иначе
		Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	КонецЕсли;	

КонецФункции	

// Возвращает количество файлов, хранящихся в томах.
//
Функция ПолучитьКоличествоФайловВТомах() Экспорт
	
	КоличествоФайловВТомах = 0;
	СтандартныеПодсистемыПереопределяемый.ПолучитьКоличествоФайловВТомах(КоличествоФайловВТомах);
	Возврат КоличествоФайловВТомах;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Служебные функции поддержки обмена файлами

// Служебная функция используется при создании начального образа
// Выполняется всегда на сервере
//
Процедура СкопироватьФайлПриСозданииНачальногоОбраза(ПолныйПуть, НовыйПутьФайла) Экспорт
	
	Попытка
		// если файл в томе - скопируем его во временный каталог (при создании начального образа)
		КопироватьФайл(ПолныйПуть, НовыйПутьФайла);
		ФайлВременный = Новый Файл(НовыйПутьФайла);
		ФайлВременный.УстановитьТолькоЧтение(Ложь);
	Исключение
		// не регистрируется, возможно файл не найден
	КонецПопытки;
	
КонецПроцедуры

// Служебная функция используется для помещения двоичных данных файла в томе
// в хранилище значения
//
Функция ПоместитьДвоичныеДанныеВХранилище(Том, ПутьКФайлу, УникальныйИдентификатор) Экспорт
	
	ПолныйПуть = ПолныйПутьТома(Том) + ПутьКФайлу;
	УникальныйИдентификатор = УникальныйИдентификатор;
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
	Возврат Новый ХранилищеЗначения(ДвоичныеДанные);
	
КонецФункции

// Служебная функции. Используется для удаления файла на сервере
// 
Процедура УдалитьФайлыНаСервере(ПрежнийПутьНаТоме) Экспорт
	
	// Удаляем файл.
	ФайлВременный = Новый Файл(ПрежнийПутьНаТоме);
	Если ФайлВременный.Существует() Тогда
		
		Попытка
			ФайлВременный.УстановитьТолькоЧтение(Ложь);
			УдалитьФайлы(ПрежнийПутьНаТоме);
		Исключение
			
			ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Удаление файлов в томе при обмене'"), 
				УровеньЖурналаРегистрации.Ошибка,,, 
				ОписаниеОшибки);
			
		КонецПопытки;
		
	КонецЕсли;
	
	// Удаляем каталог файла, если после удаления файла каталог стал пустым.
	Попытка
		МассивФайловВКаталоге = НайтиФайлы(ФайлВременный.Путь, "*.*");
		Если МассивФайловВКаталоге.Количество() = 0 Тогда
			УдалитьФайлы(ФайлВременный.Путь);
		КонецЕсли;
	Исключение
		
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Удаление файлов в томе при обмене'"), 
			УровеньЖурналаРегистрации.Ошибка,,, 
			ОписаниеОшибки);
		
	КонецПопытки;
	
КонецПроцедуры

// Получает СписокРасширенийФайловOpenDocument
//
Функция ПолучитьСписокРасширенийФайловOpenDocument() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СписокРасширенийФайловOpenDocumentОбластиДанных = Константы.СписокРасширенийФайловOpenDocumentОбластиДанных.Получить();
	Если СписокРасширенийФайловOpenDocumentОбластиДанных = Неопределено ИЛИ СписокРасширенийФайловOpenDocumentОбластиДанных = "" Тогда
		СписокРасширенийФайловOpenDocumentОбластиДанных = "ODT OTT ODP OTP ODS OTS ODC OTC ODF OTF ODM OTH SDW STW SXW STC SXC SDC SDD STI";
		Константы.СписокРасширенийФайловOpenDocumentОбластиДанных.Установить(СписокРасширенийФайловOpenDocumentОбластиДанных);
	КонецЕсли;
	
	ИтоговыйСписокРасширений = "";
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		СписокЗапрещенныхРасширений = Константы.СписокРасширенийФайловOpenDocument.Получить();
		ИтоговыйСписокРасширений = СписокЗапрещенныхРасширений + " "  + СписокРасширенийФайловOpenDocumentОбластиДанных;
	Иначе	
	    ИтоговыйСписокРасширений = СписокРасширенийФайловOpenDocumentОбластиДанных;
	КонецЕсли;	
		
	Возврат ИтоговыйСписокРасширений;
	
КонецФункции

// Получает СписокРасширенийТекстовыхФайлов
//
Функция ПолучитьСписокРасширенийТекстовыхФайлов() Экспорт

	УстановитьПривилегированныйРежим(Истина);
	СписокРасширенийТекстовыхФайлов = Константы.СписокРасширенийТекстовыхФайлов.Получить();
	Если ПустаяСтрока(СписокРасширенийТекстовыхФайлов) Тогда
		СписокРасширенийТекстовыхФайлов = "TXT";
	КонецЕсли;	
	Возврат СписокРасширенийТекстовыхФайлов;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочие служебные функции

// Возвращает Истина, если есть хранимые файлы к объекту ВнешнийОбъект.
//
Функция ЕстьХранимыеФайлы(ВнешнийОбъект) Экспорт
	
	Результат = Ложь;
	СтандартныеПодсистемыПереопределяемый.ОпределитьНаличиеХранимыхФайлов(ВнешнийОбъект, Результат);
	Возврат Результат;
	
КонецФункции

// Возвращает хранимые файлы к объекту ВнешнийОбъект
//
Функция ПолучитьХранимыеФайлы(ВнешнийОбъект) Экспорт
	
	МассивДанных = Новый Массив;
	СтандартныеПодсистемыПереопределяемый.ПолучитьХранимыеФайлы(ВнешнийОбъект, МассивДанных);
	Возврат МассивДанных;
	
КонецФункции

// Получает кодировку текстового файла, указанную пользователем (если есть).
//
// Параметры:
//  ВерсияФайла - ссылка на версию файла.
//
// Возвращаемое значение:
//  Строка - идентификатор кодировки текста или пустая строка.
//
Функция ПолучитьКодировкуВерсииФайла(ВерсияФайла) Экспорт
	
	Кодировка = "";
	СтандартныеПодсистемыПереопределяемый.ПолучитьКодировкуВерсииФайла(ВерсияФайла, Кодировка);
	
	Возврат Кодировка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
//  ЭЦП для файлов

// Проверяет все подписи (на сервере) из массива ДанныеВыделенныхСтрок
Процедура ПроверитьНаСервере(ДанныеВыделенныхСтрок) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ПровайдерЭЦП = Константы.ПровайдерЭЦП.Получить();
	ПутьМодуляКриптографии = ЭлектроннаяЦифроваяПодписьПовтИсп.ПутьМодуляКриптографии();
	ТипПровайдераЭЦП = Константы.ТипПровайдераЭЦП.Получить();
	АлгоритмПодписи = Константы.АлгоритмПодписи.Получить();
	АлгоритмХеширования = Константы.АлгоритмХеширования.Получить();
	АлгоритмШифрования = Константы.АлгоритмШифрования.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	МенеджерКриптографии = Новый МенеджерКриптографии(ПровайдерЭЦП, ПутьМодуляКриптографии, ТипПровайдераЭЦП);		
	МенеджерКриптографии.АлгоритмПодписи = АлгоритмПодписи;
	МенеджерКриптографии.АлгоритмХеширования = АлгоритмХеширования;
	МенеджерКриптографии.АлгоритмШифрования = АлгоритмШифрования;
	
	Для Каждого ДанныеСтроки Из ДанныеВыделенныхСтрок Цикл
		Если ДанныеСтроки.Объект <> Неопределено И (НЕ ДанныеСтроки.Объект.Пустая()) Тогда
			ПроверитьОднуПодписьНаСервере(ДанныеСтроки, МенеджерКриптографии);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет все подписи (на сервере) из ТаблицаПодписей
Процедура ПроверитьВсеНаСервере(ТаблицаПодписей) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ПровайдерЭЦП = Константы.ПровайдерЭЦП.Получить();
	ПутьМодуляКриптографии = ЭлектроннаяЦифроваяПодписьПовтИсп.ПутьМодуляКриптографии();
	ТипПровайдераЭЦП = Константы.ТипПровайдераЭЦП.Получить();
	АлгоритмПодписи = Константы.АлгоритмПодписи.Получить();
	АлгоритмХеширования = Константы.АлгоритмХеширования.Получить();
	АлгоритмШифрования = Константы.АлгоритмШифрования.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	МенеджерКриптографии = Новый МенеджерКриптографии(ПровайдерЭЦП, ПутьМодуляКриптографии, ТипПровайдераЭЦП);		
	МенеджерКриптографии.АлгоритмПодписи = АлгоритмПодписи;
	МенеджерКриптографии.АлгоритмХеширования = АлгоритмХеширования;
	МенеджерКриптографии.АлгоритмШифрования = АлгоритмШифрования;
	
	Для Каждого Строка Из ТаблицаПодписей Цикл
		Если Строка.Объект <> Неопределено И (НЕ Строка.Объект.Пустая()) Тогда
			ПроверитьОднуПодписьНаСервере(Строка, МенеджерКриптографии);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет одну подпись( на сервере)
Процедура ПроверитьОднуПодписьНаСервере(ДанныеСтроки, МенеджерКриптографии)
	
	СтруктураВозврата = СтандартныеПодсистемыПереопределяемый.ПолучитьДвоичныеДанныеФайлаИПодписи(
		ДанныеСтроки);
	
	ДвоичныеДанныеФайла = СтруктураВозврата.ДвоичныеДанные;
	ДвоичныеДанныеПодписи = СтруктураВозврата.ДвоичныеДанныеПодписи;
	
	Попытка
		ЭлектроннаяЦифроваяПодпись.ПроверитьПодпись(МенеджерКриптографии, ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи);
		ДанныеСтроки.Статус = НСтр("ru = 'Верна'");
		ДанныеСтроки.Неверна = Ложь;
	Исключение
		ДанныеСтроки.Статус = НСтр("ru = 'Неверна. '");
		Инфо = ИнформацияОбОшибке();
		Если Инфо.Причина <> Неопределено Тогда
			ДанныеСтроки.Статус = ДанныеСтроки.Статус + Инфо.Причина.Описание;
		КонецЕсли;
		ДанныеСтроки.Неверна = Истина;
	КонецПопытки;
	
КонецПроцедуры

// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

// Добавляет в список Обработчики процедуры-обработчики обновления,
// необходимые данной подсистеме.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                   общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ЗарегистрироватьОбработчикиОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.1.6";
	Обработчик.Процедура = "ФайловыеФункцииСлужебный.ПеренестиКонстантыРасширений";
	
КонецПроцедуры	

// Перенести константы СписокЗапрещенныхРасширений и СписокРасширенийФайловOpenDocument
Процедура ПеренестиКонстантыРасширений() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		СписокЗапрещенныхРасширений = Константы.СписокЗапрещенныхРасширений.Получить();
		Константы.СписокЗапрещенныхРасширенийОбластиДанных.Установить(СписокЗапрещенныхРасширений);
		
		СписокРасширенийФайловOpenDocument = Константы.СписокРасширенийФайловOpenDocument.Получить();
		Константы.СписокРасширенийФайловOpenDocumentОбластиДанных.Установить(СписокРасширенийФайловOpenDocument);
		
	КонецЕсли;	
	
КонецПроцедуры	
