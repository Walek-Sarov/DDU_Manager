///////////////////////////////////////////////////////////////////////////////////
// ПоставляемыеДанные: Механизм сервиса поставляемых данных.
//
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Получить дескрипторы данных по заданным условиям
//
// Параметры
//  ВидДанных - Строка. 
//  Фильтр - Коллекция. Элементы должны содержать поля Код (строка) и Значение (строка).
//
// Возвращаемое значение
//    ОбъектXDTO типа ArrayOfDescriptor
//
Функция ДескрипторыПоставляемыхДанныхИзМенеджера(Знач ВидДанных, Знач Фильтр = Неопределено) Экспорт  
	Перем Прокси, Условия, ТипФильтра;
	Прокси = НовыйПроксиНаМенеджереСервиса();
	
	Если Фильтр <> Неопределено Тогда
			
		ТипФильтра = Прокси.ФабрикаXDTO.Тип("http://www.1c.ru/SaaS/SuppliedData",
				"ArrayOfProperty");
		Условия = Прокси.ФабрикаXDTO.Создать(ТипФильтра);
		Для каждого СтрокаФльтра Из Фильтр Цикл
			Условие = Условия.Property.Добавить();
			Условие.Code = СтрокаФльтра.Код;
			Условие.Value = СтрокаФльтра.Значение;
		КонецЦикла;
	КонецЕсли;
	
	//Конвертируем в стандартный тип
	Результат = Прокси.GetData(ВидДанных, Условия);
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Прокси.ФабрикаXDTO.ЗаписатьXML(Запись, Результат, , , , НазначениеТипаXML.Явное);
	СериализованныйРезультат = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(СериализованныйРезультат);
	Результат = ФабрикаXDTO.ПрочитатьXML(Чтение);
	Чтение.Закрыть();
	Возврат Результат;

КонецФункции

// Инициирует обработку данных 
//
// Может использоваться в связке с ДескрипторыПоставляемыхДанныхИзМенеджера для 
// ручной инициации процесса обработки данных. После вызова метода система поведет 
// себя так, как будто она только что получила уведомление о доступности новых данных, 
// с указанным дескриптором – будет вызван ДоступныНовыеДанные, а затем, при необходимости, 
// ОбработатьНовыеДанные для соответствующих обработчиков.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO Descriptor.
//
Процедура ЗагрузитьИОбработатьДанные(Знач Дескриптор) Экспорт
	
	ОбработчикКаналовСообщенийПоставляемыхДанных.ОбработатьНовыйДескриптор(Дескриптор);
	
КонецПроцедуры
	
// Помещает данные в справочник ПоставляемыеДанные
//
// Данные сохраняются либо в том на диске, либо в поле таблицы ПоставляемыеДанные в 
// зависимости от константы ХранитьФайлыВТомахНаДиске и наличия свободных томов. Данные 
// могут быть позднее извлечены при помощи поиска по реквизитам, либо путем указания 
// уникального идентификатора, который передавался в поле Дескриптор.FileGUID. Если в базе 
// уже есть данные с тем же видом данных и набором ключевых характеристик – новые данные 
// замещают старые. При это используется обновление существующего элемента справочника, а 
// не удаление и создание нового.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO Descriptor или структура с полями 
//	 	"ВидДанных, ДатаДобавления, ИдентификаторФайла, Характеристики",
//    	где Характеристики - массив структур с полями "Код, Значение, Ключевая"
//   ПутьКФайлу   - строка. Полное имя извлеченного файла.
//
Процедура СохранитьПоставляемыеДанныеВКэш(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	//Приводим дескриптор к каноническому виду
	Если ТипЗнч(Дескриптор) = Тип("Структура") Тогда
		НаАнглийском = Новый Структура("DataType, CreationDate, FileGUID, Properties", 
			Дескриптор.ВидДанных, Дескриптор.ДатаДобавления, Дескриптор.ИдентификаторФайла,
			Новый Структура("Property", Новый Массив));
		Если ТипЗнч(Дескриптор.Характеристики) = Тип("Массив") Тогда
			Для каждого Характеристика Из Дескриптор.Характеристики Цикл
				НаАнглийском.Properties.Property.Добавить(Новый Структура("Code, Value, IsKey",
				Характеристика.Код, Характеристика.Значение, Характеристика.Ключевая));
			КонецЦикла; 
		КонецЕсли;
		Дескриптор = НаАнглийском;			
	КонецЕсли;
	
	Фильтр = Новый Массив;
	Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
		Если Характеристика.IsKey Тогда
			Фильтр.Добавить(Новый Структура("Код, Значение", Характеристика.Code, Характеристика.Value));
		КонецЕсли;
	КонецЦикла;
	
	Запрос = ЗапросДанныхПоИменам(Дескриптор.DataType, Фильтр);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Данные = Неопределено;
	ПутьКСтаромуФайлу = Неопределено;
	
	Пока Выборка.Следующий() Цикл
		Если Данные = Неопределено Тогда
			Данные = Выборка.ПоставляемыеДанные.ПолучитьОбъект();
			Если Данные.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
				ПутьКСтаромуФайлу = ФайловыеФункцииСлужебный.ПолныйПутьТома(Данные.Том) + Данные.ПутьКФайлу;
			КонецЕсли;
		Иначе
			УдалитьПоставляемыеДанныеИзКэша(Выборка.ПоставляемыеДанные);
		КонецЕсли;
	КонецЦикла;		
	
	Если Данные = Неопределено Тогда
		Данные = Справочники.ПоставляемыеДанные.СоздатьЭлемент();
	КонецЕсли;
		
	Данные.ВидДанных =  Дескриптор.DataType;
	Данные.ДатаДобавления = Дескриптор.CreationDate;
	Данные.ИдентификаторФайла = Дескриптор.FileGUID;
	Данные.ХарактеристикиДанных.Очистить();
	Для каждого Property Из Дескриптор.Properties.Property Цикл
		Характеристика = Данные.ХарактеристикиДанных.Добавить();
		Характеристика.Характеристика = Property.Code;
		Характеристика.Значение = Property.Value;
	КонецЦикла; 
	Данные.ТипХраненияФайла = ФайловыеФункцииСлужебный.ПолучитьТипХраненияФайлов();

	Если Данные.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		Данные.ХранимыйФайл = Новый ХранилищеЗначения(Новый ДвоичныеДанные(ПутьКФайлу));
		Данные.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
		Данные.ПутьКФайлу = "";
	Иначе
		// Добавление в один из томов (где есть свободное место).
		ФайловыеФункцииСлужебный.ДобавитьНаДиск(
			ПутьКФайлу,
			Данные.ПутьКФайлу,
			Данные.Том,
			Данные.ДатаДобавления,
			"",
			Строка(Данные.ИдентификаторФайла),
			"");
		Данные.ХранимыйФайл = Неопределено;
	КонецЕсли;
	
	Данные.Записать();
	Если ПутьКСтаромуФайлу <> Неопределено Тогда
		УдалитьФайлы(ПутьКСтаромуФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Удаляет файл из кеша.
//
// Параметры:
//  СсылкаИлиИдентификатор - СправочникСсылка.ПоставляемыеДанные или УникальныйИдентификатор
//
Процедура УдалитьПоставляемыеДанныеИзКэша(Знач СсылкаИлиИдентификатор) Экспорт
	Перем Данные, ПолныйПуть;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиИдентификатор) = Тип("УникальныйИдентификатор") Тогда
		СсылкаИлиИдентификатор = Справочники.ПоставляемыеДанные.НайтиПоРеквизиту("ИдентификаторФайла", СсылкаИлиИдентификатор);
		Если СсылкаИлиИдентификатор.Пустая() Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Данные = СсылкаИлиИдентификатор.ПолучитьОбъект();
	Если Данные.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(Данные.Том) + Данные.ПутьКФайлу;
		УдалитьФайлы(ПолныйПуть);
	КонецЕсли;
	
	Удаление = Новый УдалениеОбъекта(СсылкаИлиИдентификатор);
	Удаление.ОбменДанными.Загрузка = Истина;
	Удаление.Записать();
	
КонецПроцедуры

// Возвращает двоичные данные присоединенного файла.
//
// Параметры:
//  СсылкаИлиИдентификатор - СправочникСсылка.ПоставляемыеДанные 
//                       или УникальныйИдентификатор - идентификатор файла
//
// Возвращаемое значение:
//  ДвоичныеДанные.
//
Функция ПоставляемыеДанныеИзКэша(Знач СсылкаИлиИдентификатор) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиИдентификатор) = Тип("УникальныйИдентификатор") Тогда
		СсылкаИлиИдентификатор = Справочники.ПоставляемыеДанные.НайтиПоРеквизиту("ИдентификаторФайла", СсылкаИлиИдентификатор);
		Если СсылкаИлиИдентификатор.Пустая() Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	ФайлОбъект = СсылкаИлиИдентификатор.ПолучитьОбъект();
	Если ФайлОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ФайлОбъект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		Возврат ФайлОбъект.ХранимыйФайл.Получить();
	Иначе
		ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(ФайлОбъект.Том) + ФайлОбъект.ПутьКФайлу;
		
		Попытка
			Возврат Новый ДвоичныеДанные(ПолныйПуть)
		Исключение
			// Запись в журнал регистрации.
			СообщениеОбОшибке = ТекстОшибкиПриПолученииФайла(ИнформацияОбОшибке(), СсылкаИлиИдентификатор);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Поставляемые данные.Получение файла из тома'"),
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.Справочники.ПоставляемыеДанные,
				СсылкаИлиИдентификатор,
				СообщениеОбОшибке);
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка открытия файла: файл не найден на сервере.
				           |Обратитесь к администратору.
				           |
				           |Файл: ""%1.%2"".'"),
				ФайлОбъект.Наименование,
				ФайлОбъект.Расширение);
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Проверяет наличие данных с указанными ключевыми характеристиками в кеше.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO Descriptor.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьВКеше(Знач Дескриптор) Экспорт
	
	Фильтр = Новый Массив;
	Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
		Если Характеристика.IsKey Тогда
			Фильтр.Добавить(Новый Структура("Код, Значение", Характеристика.Code, Характеристика.Value));
		КонецЕсли;
	КонецЦикла;
	
	Запрос = ЗапросДанныхПоИменам(Дескриптор.DataType, Фильтр);
	Возврат Запрос.Выполнить().Выгрузить().Количество() > 0;

	
КонецФункции

// Возвращает массив ссылок на данные, удовлетворяющие заданным условиям
//
// Параметры
//  ВидДанных - Строка. 
//  Фильтр - Коллекция. Элементы должны содержать поля Код (строка) и Значение (строка).
//
// Возвращаемое значение
//    Массив
//
Функция СсылкиПоставляемыхДанныхИзКэша(Знач ВидДанных, Знач Фильтр = Неопределено) Экспорт
	
	Запрос = ЗапросДанныхПоИменам(ВидДанных, Фильтр);
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ПоставляемыеДанные");
	
КонецФункции

// Получить данные по заданным условиям
//
// Параметры
//  ВидДанных - Строка. 
//  Фильтр - Коллекция. Элементы должны содержать поля Код (строка) и Значение (строка).
//  ВВидеXDTO - булево. В каком виде возвращать значения
//
// Возвращаемое значение
//    ОбъектXDTO типа ArrayOfDescriptor или 
//    Массив структур с полями "ВидДанных, ДатаДобавления, ИдентификаторФайла, Характеристики",
//    где Характеристики - массив структур с полями "Код, Значение, Ключевая"
//	  Для получения самого файла необходимо вызвать ПолучитьПоставляемыеДанныеИзКэша
//
//
Функция ДескрипторыПоставляемыхДанныхИзКэша(Знач ВидДанных, Знач Фильтр = Неопределено, Знач ВВидеXDTO = Ложь) Экспорт
	Перем Запрос, РезультатЗапроса, Выборка, Дескрипторы, Результат;
	
	Запрос = ЗапросДанныхПоИменам(ВидДанных, Фильтр);
		
	Запрос.Текст = "ВЫБРАТЬ
    |	СправочникПоставляемыеДанные.ИдентификаторФайла,
    |	СправочникПоставляемыеДанные.ДатаДобавления,
    |	СправочникПоставляемыеДанные.ВидДанных КАК КодВидаДанных,
    |	СправочникПоставляемыеДанные.ХарактеристикиДанных.(
    |		Значение,
    |		Характеристика)
	|ИЗ
	|	Справочник.ПоставляемыеДанные КАК СправочникПоставляемыеДанные
	|	ГДЕ СправочникПоставляемыеДанные.Ссылка В (" + Запрос.Текст + ")";
	 
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	
	Если ВВидеXDTO Тогда
		Результат = СоздатьОбъект(ФабрикаXDTO.Тип("http://www.1c.ru/SaaS/SuppliedData",
				"ArrayOfDescriptor"));
		Дескрипторы = Результат.Descriptor;
	Иначе
		Результат = Новый Массив();
		Дескрипторы = Результат;
	КонецЕсли;

	Пока Выборка.Следующий()  Цикл
		Сообщение = ?(ВВидеXDTO, ПолучитьXDTOДескриптор(Выборка), ПолучитьДескриптор(Выборка));
		Дескрипторы.Добавить(Сообщение);
	КонецЦикла;		
	
	Возврат Результат;
	
КонецФункции	

// Возвращает список областей данных, в которые еще не были скопированы поставляемые данные
//
// В случае первого вызова фукнции возвращается полный набор доступных областей
// При последующем вызове, при восстановлении после сбоя, будут возвращены только
// необработанные области. После копированя данных в область следует вызвать УдалитьНеобработаннуюОбласть
//
// Параметры
//  ИдентификаторФайла - УникальныйИдентификатор файла поставляемых данных
//  КодОбработчика - Строка
// 
Функция ОбластиТребующиеОбработки(Знач ИдентификаторФайла, Знач КодОбработчика) Экспорт
	
	НаборЗаписей = РегистрыСведений.ОбластиТребующиеОбработкиПоставляемыхДанных.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ИдентификаторФайла.Установить(ИдентификаторФайла);
	НаборЗаписей.Отбор.КодОбработчика.Установить(КодОбработчика);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество() = 0 Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
					   |	&ИдентификаторФайла КАК ИдентификаторФайла,
					   |	&КодОбработчика КАК КодОбработчика,
					   |	ОбластиДанных.ОбластьДанных
		               |ИЗ
		               |	РегистрСведений.ОбластиДанных КАК ОбластиДанных";
		Запрос.УстановитьПараметр("ИдентификаторФайла", ИдентификаторФайла);
		Запрос.УстановитьПараметр("КодОбработчика", КодОбработчика);
		НаборЗаписей.Загрузить(Запрос.Выполнить().Выгрузить());
		
		Если КодОбработчика = "КурсыВалютЗаДень" Тогда
			ОбщиеКурсы = НаборЗаписей.Добавить();
			ОбщиеКурсы.ИдентификаторФайла = ИдентификаторФайла;
			ОбщиеКурсы.КодОбработчика = КодОбработчика;
			ОбщиеКурсы.ОбластьДанных = -1;
		КонецЕсли;
		
		НаборЗаписей.Записать();
	КонецЕсли;
	Возврат НаборЗаписей.ВыгрузитьКолонку("ОбластьДанных");
КонецФункции	

// Удаляет область из списка необработанных
//
// Параметры
//  ИдентификаторФайла - УникальныйИдентификатор файла поставляемых данных
//  КодОбработчика - Строка
//  ОбластьДанных - Число, идентификатор обработанной области
// 
Процедура ОбластьОбработана(Знач ИдентификаторФайла, Знач КодОбработчика, Знач ОбластьДанных) Экспорт
	
	НаборЗаписей = РегистрыСведений.ОбластиТребующиеОбработкиПоставляемыхДанных.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ИдентификаторФайла.Установить(ИдентификаторФайла);
	Если ОбластьДанных <> Неопределено Тогда
		НаборЗаписей.Отбор.ОбластьДанных.Установить(ОбластьДанных);
	КонецЕсли;
	НаборЗаписей.Отбор.КодОбработчика.Установить(КодОбработчика);
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Функция возвращает прокси web-сервиса для обновления общих поставляемых данных
// 
// Возвращаемое значение: 
// WSПрокси.
// Прокси сервиса поставляемых данных.
//
Функция ПолучитьПроксиСервисаПоставляемыхДанных() Экспорт
	
	АдресСервисаПоставляемыхДанных = Константы.АдресСервисаПоставляемыхДанных.Получить();
	Если Не ЗначениеЗаполнено(АдресСервисаПоставляемыхДанных) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с сервисом поставляемых данных.'"));
	КонецЕсли;
	
	АдресСервиса = АдресСервисаПоставляемыхДанных + "/ws/SuppliedData?wsdl";
	
	ИмяПользователя = Константы.ИмяСлужебногоПользователяСервисаПоставляемыхДанных.Получить();
	ПарольПользователя = Константы.ПарольСлужебногоПользователяСервисаПоставляемыхДанных.Получить();
	
	Прокси = ОбщегоНазначенияПовтИсп.WSПрокси(АдресСервиса, "http://www.1c.ru/supplieddata",
		"SuppliedData", , ИмяПользователя, ПарольПользователя, 1200);
	
	Возврат Прокси;
	
КонецФункции

// Процедура регламетного задания обновляет общие данные из сервиса поставляемых данных
//
Процедура ОбновлениеОбщихПоставляемыхДанных() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Прокси = ПолучитьПроксиСервисаПоставляемыхДанных();
	
	FilterТип = Прокси.ФабрикаXDTO.Тип("http://www.1c.ru/supplieddata", "Filter");
	Filter = Прокси.ФабрикаXDTO.Создать(FilterТип);
	
	FilterItemТип = Прокси.ФабрикаXDTO.Тип("http://www.1c.ru/supplieddata", "FilterItem");
	
	ТаблицаСоответствия = ОбщегоНазначения.ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим();
	Для Каждого Строка Из ТаблицаСоответствия Цикл
		Версия = ПолучитьВерсиюПоставляемыхДанных(Строка.ТипОбщихДанных);
		
		FilterItem = Прокси.ФабрикаXDTO.Создать(FilterItemТип);
		FilterItem.Type = XMLСтрока(Строка.ВидПоставляемыхДанных);
		FilterItem.Version = Версия;
		Filter.FilterItem.Добавить(FilterItem);
		
	КонецЦикла;
	
	Results = Прокси.GetSuppliedData(Filter);
	
	НомерЗагрузки = Константы.НомерЗагрузкиПоставляемыхДанных.Получить() + 1;
	
	ЗагрузитьДанные(Results, НомерЗагрузки);
	
	Константы.НомерЗагрузкиПоставляемыхДанных.Установить(НомерЗагрузки);
	
	КонтрольОбновленияРазделенныхПоставляемыхДанных();
	
КонецПроцедуры

// Процедура фонового задания обновляет разделенные данные из общих
// запускается из фоновых заданий
//
Процедура ОбновитьПоставляемыеДанные(ОбластьДанных, НомерСообщения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НачатьТранзакцию();
	Попытка
		Ключ = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьКлючЗаписи(
			Новый Структура("ОбластьДанных, НомерСообщения", ОбластьДанных, НомерСообщения));
		
		ЗаблокироватьДанныеДляРедактирования(Ключ);
		
		Для Каждого ЭлементСостава Из Метаданные.ПланыОбмена.ИзмененияПоставляемыхДанных.Состав Цикл
			
			ОбъектМД = ЭлементСостава.Метаданные;
			
			Если Метаданные.РегистрыСведений.Содержит(ОбъектМД) Тогда
				ЭтоРегистрСведений = Истина;
				ТипИсточника = Тип("РегистрСведенийКлючЗаписи." + ОбъектМД.Имя);
				ТипПриемника = ПолучитьТипРазделенныхДанныхПоОбщему(ТипИсточника);
				МДПриемника = Метаданные.НайтиПоТипу(ТипПриемника);
				Менеджер = РегистрыСведений[МДПриемника.Имя];
			Иначе
				ЭтоРегистрСведений = Ложь;
				ТипИсточника = Тип("СправочникСсылка." + ОбъектМД.Имя);
				ТипПриемника = ПолучитьТипРазделенныхДанныхПоОбщему(ТипИсточника);
				МДПриемника = Метаданные.НайтиПоТипу(ТипПриемника);
				Менеджер = Справочники[МДПриемника.Имя];
			КонецЕсли;
			
			ВыборкаИзменений = ПланыОбмена.ВыбратьИзменения(
				ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(ОбластьДанных), 0, ОбъектМД);
			
			Пока ВыборкаИзменений.Следующий() Цикл
				
				ОбъектПриемник = Неопределено;
				
				Эталон = ВыборкаИзменений.Получить();
				
				СтандартаяОбработка = Истина;
				
				Если ЭтоРегистрСведений Тогда
					
					СтандартныеПодсистемыПереопределяемый.ПередКопированиемНабораЗаписейИзЭталона(Эталон,
						ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник, СтандартаяОбработка);
						
					ПоставляемыеДанныеПереопределяемый.ПередКопированиемНабораЗаписейИзЭталона(Эталон,
						ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник, СтандартаяОбработка);
						
					Если СтандартаяОбработка Тогда
						СкопироватьНаборЗаписейИзЭталона(Эталон,
							ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник);
					КонецЕсли;
				Иначе
					
					СтандартныеПодсистемыПереопределяемый.ПередКопированиемОбъектаИзЭталона(Эталон,
						ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник, СтандартаяОбработка);
						
					ПоставляемыеДанныеПереопределяемый.ПередКопированиемОбъектаИзЭталона(Эталон,
						ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник, СтандартаяОбработка);
						
					Если СтандартаяОбработка Тогда
						СкопироватьОбъектИзЭталона(Эталон,
							ОбъектМД, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник);
					КонецЕсли;
				КонецЕсли;
				ОбъектПриемник.Записать();
			КонецЦикла;
			
			ПланыОбмена.УдалитьРегистрациюИзменений(ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(ОбластьДанных), 0);
			
		КонецЦикла;
		
		Менеджер = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанных = ОбластьДанных;
		Менеджер.НомерСообщения = НомерСообщения;
		Менеджер.Удалить();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Обновление поставляемых данных'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Процедура регламетного задания контролирует РС ОбластиДляОбновленияПоставляемыхДанных
// и в случае некорректного завершения фоновых заданий запускает их повторно
//
Процедура КонтрольОбновленияРазделенныхПоставляемыхДанных() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДляОбновленияПоставляемыхДанных.ОбластьДанных,
	|	ОбластиДляОбновленияПоставляемыхДанных.НомерСообщения
	|ИЗ
	|	РегистрСведений.ОбластиДляОбновленияПоставляемыхДанных КАК ОбластиДляОбновленияПоставляемыхДанных";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Ключ = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьКлючЗаписи(
			Новый Структура("ОбластьДанных, НомерСообщения", Выборка.ОбластьДанных, Выборка.НомерСообщения));
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			Продолжить;
		КонецПопытки;
		
		Менеджер = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанных = Выборка.ОбластьДанных;
		Менеджер.НомерСообщения = Выборка.НомерСообщения;
		
		НачатьТранзакцию();
		Попытка
			Менеджер.Прочитать();
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Контроль обновления поставляемых данных'"), 
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
		Если Не Менеджер.Выбран() Тогда
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		ОтборЗадания = Новый Структура;
		ОтборЗадания.Вставить("ИмяМетода", "ПоставляемыеДанные.ОбновитьПоставляемыеДанные");
		ОтборЗадания.Вставить("Ключ", Формат(Выборка.НомерСообщения, "ЧГ="));
		ЗапланированноеЗадание = ОчередьЗаданий.ПолучитьЗадание(ОтборЗадания, Выборка.ОбластьДанных);
		Если ЗапланированноеЗадание <> Неопределено Тогда
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(Выборка.ОбластьДанных);
		ПараметрыМетода.Добавить(Выборка.НомерСообщения);
		
		ОчередьЗаданий.ЗапланироватьВыполнениеЗадания("ПоставляемыеДанные.ОбновитьПоставляемыеДанные",
			ПараметрыМетода, Формат(Выборка.НомерСообщения, "ЧГ="),, Выборка.ОбластьДанных); 
		
		РазблокироватьДанныеДляРедактирования(Ключ);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура обработчик подписки на событие "Перед записью" справочника общих данных:
// регистрирует получателей в плане обмена для источника
// пишет уникальные узлы в РС ОбластиДляОбновленияПоставляемыхДанных
//
Процедура СправочникиОбщихПоставляемыхДанныхПередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	ТекущаяСсылка = Источник.Ссылка;
	ТипИсточника = ТипЗнч(Источник.Ссылка);
	ВыборкаУзлов = Неопределено;
	
	Если Источник.ЭтоНовый() Тогда
		
		Если ПоставляемыеДанныеПовтИсп.НеобходимоДобавитьЭлементВОбласти(Новый(ТипИсточника)) Тогда 
			
			ТекущаяСсылка = Источник.ПолучитьСсылкуНового();
			
			Если НЕ ЗначениеЗаполнено(ТекущаяСсылка) Тогда
				
				МенеджерОбъектаИсточника = ПоставляемыеДанныеПовтИсп.ПолучитьМенеджерПоПустойСсылкеТипа(Новый(ТипИсточника));
				ТекущаяСсылка = МенеджерОбъектаИсточника.ПолучитьСсылку();
				Источник.УстановитьСсылкуНового(ТекущаяСсылка);
				
			КонецЕсли;
			
			Параметры = Новый Массив();
			Параметры.Добавить(ТекущаяСсылка.УникальныйИдентификатор());
			
			ТипПриемника = ПолучитьТипРазделенныхДанныхПоОбщему(ТипИсточника);
			
			РазделеннаяСсылка = Новый(ТипПриемника, Параметры);
			
			Запрос = Новый Запрос;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ИзмененияПоставляемыхДанных.ОбластьДанных,
			|	ИзмененияПоставляемыхДанных.Ссылка КАК Узел
			|ИЗ
			|	ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ОбластиДанных КАК ОбластиДанных
			|		ПО ИзмененияПоставляемыхДанных.ОбластьДанных = ОбластиДанных.ОбластьДанных
			|ГДЕ
			|	ОбластиДанных.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Используется))";
			
			ВыборкаУзлов = Запрос.Выполнить().Выбрать();
			Пока ВыборкаУзлов.Следующий() Цикл
				
				МенеджерЗаписи = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
				МенеджерЗаписи.ОбластьДанных = ВыборкаУзлов.ОбластьДанных;
				МенеджерЗаписи.ЭлементОбщихДанных = ТекущаяСсылка;
				МенеджерЗаписи.ЭлементРазделенныхДанных = РазделеннаяСсылка;
				МенеджерЗаписи.РучноеИзменение = Ложь;
				МенеджерЗаписи.Записать();
				
			КонецЦикла;
			ВыборкаУзлов.Сбросить();
		КонецЕсли;
		ПоставляемыеДанныеПереопределяемый.ПриРегистрацииНовогоОбъектаПоставляемыхДанных(Источник);
		
	КонецЕсли;
	
	Если ВыборкаУзлов = Неопределено Тогда
		ВыборкаУзлов = ПолучитьМассивУзловИспользованияЭлементаДанных(ТекущаяСсылка);
	КонецЕсли;
	
	Если Источник.ДополнительныеСвойства.Свойство("НомерЗагрузки") Тогда
		НомерЗагрузки = Источник.ДополнительныеСвойства.НомерЗагрузки;
	Иначе
		НомерЗагрузки = Константы.НомерЗагрузкиПоставляемыхДанных.Получить();
	КонецЕсли;
	
	Источник.ОбменДанными.Получатели.Очистить();
	Пока ВыборкаУзлов.Следующий() Цикл
		Источник.ОбменДанными.Получатели.Добавить(ВыборкаУзлов.Узел);
		
		Если ДобавитьОбластьДанныхВСписокУзлов(ВыборкаУзлов.ОбластьДанных, НомерЗагрузки) Тогда
			Менеджер = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
			Менеджер.ОбластьДанных = ВыборкаУзлов.ОбластьДанных;
			Менеджер.НомерСообщения = НомерЗагрузки;
			Менеджер.Записать();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура обработчик подписки на событие "Перед удалением" справочника разделенных данных:
// удаляет связи в текущей области для разделенных элементов
//
Процедура СправочникиРазделенныхПоставляемыхДанныхПередУдалением(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	УдалитьСвязьПоставляемыхДанных(Источник.Ссылка);	

КонецПроцедуры

// Удаляет связь с элеметном общего справочника
//
// Параметры:
//   ЭлементРазделенныхДанных, СправочникСсылка - ссылка на элемент разделенного справочника
//
Процедура УдалитьСвязьПоставляемыхДанных(Знач ЭлементРазделенныхДанных) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СвязиПоставляемыхДанных.ЭлементОбщихДанных КАК Ссылка
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|ГДЕ
	|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
	|	И СвязиПоставляемыхДанных.ЭлементРазделенныхДанных = &ЭлементРазделенныхДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	Запрос.УстановитьПараметр("ЭлементРазделенныхДанных", ЭлементРазделенныхДанных);
	
	УстановитьПривилегированныйРежим(Истина);
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Не Результат.Пустой() Тогда
		Менеджер = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
		Менеджер.ЭлементОбщихДанных = Результат.Выгрузить()[0].Ссылка;
		Менеджер.ЭлементРазделенныхДанных = ЭлементРазделенныхДанных;
		Менеджер.Удалить();
	КонецЕсли;
	
КонецПроцедуры

// Связывает общие и разделенные данные. Если в таблицах связей уже присутствует
//
// Параметры
//   Связи - коллекция со следующими полями: 
//     ЭлементРазделенныхДанных (СправочникСсылка)
//     ЭлементОбщихДанных (СправочникСсылка, Строка)
//     ТипОбщихДанных (Строка)
//
//   СкопироватьДанныеСейчас, булево - Истина - функиця после создания связей переносит 
//      данные из общего классификатора в разделенный, Ложь - данный перенос будет
//      осуществляться позднее, в фоновом задании
//  
Процедура СвязатьСКлассификатором(Знач Связи, Знач СкопироватьДанныеСейчас = Ложь) Экспорт
	
	Если Связи.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	Ключ = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьКлючЗаписи(
		Новый Структура("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса()));
	
	ЗаблокироватьДанныеДляРедактирования(Ключ);
	
	НачатьТранзакцию();
	Попытка
		
		Запрос = Новый Запрос;
		УсловияСвязи = "";
		Индекс = 1;
		Для каждого Связь Из Связи Цикл
			Если УсловияСвязи <> "" Тогда 
				УсловияСвязи = УсловияСвязи + " Или ";
			КонецЕсли;
			УсловияСвязи = УсловияСвязи + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"((ТипОбщихДанных = &ТипОбщихДанных%1 И ЭлементОбщихДанных = &ЭлементОбщихДанных%1)
			| Или ЭлементРазделенныхДанных = &ЭлементРазделенныхДанных%1)", Формат(Индекс,"ЧГ=0"));
			Запрос.УстановитьПараметр("ТипОбщихДанных" + Формат(Индекс,"ЧГ=0"), Связь.ТипОбщихДанных);
			Запрос.УстановитьПараметр("ЭлементОбщихДанных" + Формат(Индекс,"ЧГ=0"), Связь.ЭлементОбщихДанных);
			Запрос.УстановитьПараметр("ЭлементРазделенныхДанных" + Формат(Индекс,"ЧГ=0"), Связь.ЭлементРазделенныхДанных);
			
			Индекс = Индекс + 1;
		КонецЦикла; 
		
		Запрос.Текст =
		"ВЫБРАТЬ
		|	СвязиПоставляемыхДанных.ТипОбщихДанных,
		|	СвязиПоставляемыхДанных.ЭлементОбщихДанных,
		|	СвязиПоставляемыхДанных.ЭлементРазделенныхДанных
		|ИЗ
		|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
		|ГДЕ
		|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
		|	И (" + УсловияСвязи + ")";
		Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
		
		УстановитьПривилегированныйРежим(Истина);
		ТаблицаСоответствия = Запрос.Выполнить().Выгрузить();
		
		//Стираем старые связи, если есть
		Для каждого СтрокаСоответствия Из ТаблицаСоответствия Цикл
			Менеджер = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
			Менеджер.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
			Менеджер.ТипОбщихДанных = СтрокаСоответствия.ТипОбщихДанных;
			Менеджер.ЭлементОбщихДанных = СтрокаСоответствия.ЭлементОбщихДанных;
			Менеджер.ЭлементРазделенныхДанных = СтрокаСоответствия.ЭлементРазделенныхДанных;
			Менеджер.Удалить();
		КонецЦикла; 
		УстановитьПривилегированныйРежим(Ложь);
		
		//Добавляем новые связи
		Для Каждого Связь Из Связи Цикл
			
			УстановитьПривилегированныйРежим(Истина);
			
			МенеджерЗаписи = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
			МенеджерЗаписи.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
			МенеджерЗаписи.ТипОбщихДанных = Связь.ТипОбщихДанных;
			МенеджерЗаписи.ЭлементОбщихДанных = Связь.ЭлементОбщихДанных;
			МенеджерЗаписи.ЭлементРазделенныхДанных = Связь.ЭлементРазделенныхДанных;
			МенеджерЗаписи.РучноеИзменение = Ложь;
			МенеджерЗаписи.Записать();
			
			Если ТипЗнч(Связь.ЭлементОбщихДанных) <> Тип("Строка") Тогда
				ПланыОбмена.ЗарегистрироватьИзменения(ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(
					ОбщегоНазначения.ЗначениеРазделителяСеанса()), Связь.ЭлементОбщихДанных);
			КонецЕсли;
				
			УстановитьПривилегированныйРежим(Ложь);
			
			СтандартныеПодсистемыПереопределяемый.ПриПодбореПоставляемыхДанныхВОбласть(Связь.ЭлементОбщихДанных, Связь.ТипОбщихДанных);
			ПоставляемыеДанныеПереопределяемый.ПриПодбореПоставляемыхДанныхВОбласть(Связь.ЭлементОбщихДанных, Связь.ТипОбщихДанных);
			
		КонецЦикла;

		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подбор из классификатора'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	УстановитьПривилегированныйРежим(Истина);
	Если СкопироватьДанныеСейчас Тогда
		ОбновитьПоставляемыеДанные(ОбщегоНазначения.ЗначениеРазделителяСеанса(), 0);
	Иначе
		Если ДобавитьОбластьДанныхВСписокУзлов(ОбщегоНазначения.ЗначениеРазделителяСеанса(), 0) Тогда
			Менеджер = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
			Менеджер.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
			Менеджер.НомерСообщения = 0;
			Менеджер.Записать();
		КонецЕсли;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

// Процедура осуществляет копирование общих данных в разделенные
//
// Параметры:
//   Ссылки, массив СправочникСсылка - набор общих данных, на основе которых нужно
//       сформировать разделенные данные в текущей области данных
//
Процедура ПодобратьИзКлассификатора(Знач Ссылки, Знач ИгнорироватьРучноеИзменение = Ложь) Экспорт
	
	Если Ссылки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если Ссылки[0].Метаданные().Иерархический Тогда
		Ссылки = ДополнитьМассивРодителямиСсылок(Ссылки);
	КонецЕсли;
	
	Ключ = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьКлючЗаписи(
		Новый Структура("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса()));
	
	ЗаблокироватьДанныеДляРедактирования(Ключ);
	
	НачатьТранзакцию();
	Попытка
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	СвязиПоставляемыхДанных.ЭлементОбщихДанных,
		|	СвязиПоставляемыхДанных.ЭлементРазделенныхДанных,
		|	СвязиПоставляемыхДанных.РучноеИзменение
		|ИЗ
		|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
		|ГДЕ
		|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
		|	И СвязиПоставляемыхДанных.ЭлементОбщихДанных В(&Ссылки)";
		Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
		Запрос.УстановитьПараметр("Ссылки", Ссылки);
		
		УстановитьПривилегированныйРежим(Истина);
		ТаблицаСоответствия = Запрос.Выполнить().Выгрузить();
		УстановитьПривилегированныйРежим(Ложь);
		
		ТаблицаСоответствия.Индексы.Добавить("ЭлементОбщихДанных");
		Для Каждого Ссылка Из Ссылки Цикл
			
			ТипПриемника = ПолучитьТипРазделенныхДанныхПоОбщему(ТипЗнч(Ссылка));
			
			СтрокаСоответствия = ТаблицаСоответствия.Найти(Ссылка, "ЭлементОбщихДанных");
			Если СтрокаСоответствия = Неопределено Тогда
				СтрокаСоответствия = ТаблицаСоответствия.Добавить();
				СтрокаСоответствия.ЭлементОбщихДанных = Ссылка;
			КонецЕсли;
			Если НЕ ЗначениеЗаполнено(СтрокаСоответствия.ЭлементРазделенныхДанных) Тогда
				Параметры = Новый Массив;
				Параметры.Добавить(Ссылка.УникальныйИдентификатор());
				СтрокаСоответствия.ЭлементРазделенныхДанных = Новый(ТипПриемника, Параметры);
			КонецЕсли;
			
			Если СтрокаСоответствия.РучноеИзменение = Истина
				И НЕ ИгнорироватьРучноеИзменение Тогда
				
				Продолжить;
			КонецЕсли;
			
			УстановитьПривилегированныйРежим(Истина);
			
			МенеджерЗаписи = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
			МенеджерЗаписи.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
			МенеджерЗаписи.ЭлементОбщихДанных = Ссылка;
			МенеджерЗаписи.ЭлементРазделенныхДанных = СтрокаСоответствия.ЭлементРазделенныхДанных;
			МенеджерЗаписи.РучноеИзменение = СтрокаСоответствия.РучноеИзменение;
			МенеджерЗаписи.Записать();
			
			ПланыОбмена.ЗарегистрироватьИзменения(ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(
				ОбщегоНазначения.ЗначениеРазделителяСеанса()), Ссылка);
				
			УстановитьПривилегированныйРежим(Ложь);
			
			СтандартныеПодсистемыПереопределяемый.ПриПодбореПоставляемыхДанныхВОбласть(Ссылка);
			ПоставляемыеДанныеПереопределяемый.ПриПодбореПоставляемыхДанныхВОбласть(Ссылка);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Подбор из классификатора'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	ОбновитьПоставляемыеДанные(ОбщегоНазначения.ЗначениеРазделителяСеанса(), 0);
	
КонецПроцедуры

// Функция получает по общей ссылке перечень узлов плана обмена
//
// Параметры:
// СсылкаЭлементаДанных - ссылка, по которой определяются узлы 
//
// Возвращаемое значение:
// Выборка результата запроса - список узлов и областей
//
Функция ПолучитьМассивУзловИспользованияЭлементаДанных(СсылкаЭлементаДанных) Экспорт
	
	// Определим список областей данных в которых используется элемент данных
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИзмененияПоставляемыхДанных.Ссылка КАК Узел,
	|	ИзмененияПоставляемыхДанных.ОбластьДанных
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
	|		ПО СвязиПоставляемыхДанных.ОбластьДанных = ИзмененияПоставляемыхДанных.ОбластьДанных
	|ГДЕ
	|	СвязиПоставляемыхДанных.ЭлементОбщихДанных = &ЭлементОбщихДанных
	|	И СвязиПоставляемыхДанных.РучноеИзменение = ЛОЖЬ";
	Запрос.УстановитьПараметр("ЭлементОбщихДанных", СсылкаЭлементаДанных);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Возврат Выборка;
	
КонецФункции

// Функция получает по общей ссылке перечень узлов плана обмена
//
// Параметры:
// СписокЭлементовДанных -Массив- список элементов, для которых определяются узлы 
//
// Возвращаемое значение:
// Выборка результата запроса - список узлов и областей
//
Функция ПолучитьМассивУзловИспользованияСпискаЭлементовДанных(СписокЭлементовДанных) Экспорт
	
	// Определим список областей данных в которых используются элементы данных
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ИзмененияПоставляемыхДанных.Ссылка КАК Узел,
	|	ИзмененияПоставляемыхДанных.ОбластьДанных
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
	|		ПО СвязиПоставляемыхДанных.ОбластьДанных = ИзмененияПоставляемыхДанных.ОбластьДанных
	|ГДЕ
	|	СвязиПоставляемыхДанных.ЭлементОбщихДанных В(&СписокЭлементовДанных)
	|	И СвязиПоставляемыхДанных.РучноеИзменение = ЛОЖЬ";
	Запрос.УстановитьПараметр("СписокЭлементовДанных", СписокЭлементовДанных);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Возврат Выборка;
	
КонецФункции

// Возвращает общую ссылку соответствующую переданной разделенной
//
// Параметры:
// РазделеннаяСсылка - СправочникСсылка - разделенная ссылка для
// которой требуется получить соответствующую общую
//
// Возвращаемое значение:
// СправочникСсылка - общая ссылка, соответствующая разделенной.
//
Функция ОбщаяСсылкаПоРазделенной(РазделеннаяСсылка) Экспорт
	
	Если РазделеннаяСсылка.Пустая() Тогда
		Возврат Новый(ПолучитьТипОбщихДанныхПоРазделенному(ТипЗнч(РазделеннаяСсылка)));
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СвязиПоставляемыхДанных.ЭлементОбщихДанных КАК Ссылка
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|ГДЕ
	|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
	|	И СвязиПоставляемыхДанных.ЭлементРазделенныхДанных = &ЭлементРазделенныхДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	Запрос.УстановитьПараметр("ЭлементРазделенныхДанных", РазделеннаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Результат.Пустой() Тогда
		Текст = НСтр("ru = 'Не найдена общая ссылка соответствующая разделенной: %РазделеннаяСсылка%'");
		Текст = СтрЗаменить(Текст, "%РазделеннаяСсылка%", РазделеннаяСсылка);
		ВызватьИсключение(Текст);
	КонецЕсли;
	
	Возврат Результат.Выгрузить()[0].Ссылка;
	
КонецФункции

// Возвращает разделенную ссылку соответствующую переданной разделенной
// в текущей области данных.
//
// Параметры:
// ОбщаяСсылка - СправочникСсылка - общая ссылка для
// которой требуется получить соответствующую разделенную
//
// Возвращаемое значение:
// СправочникСсылка - разделенной ссылка, соответствующая общей.
//
Функция РазделеннаяСсылкаПоОбщей(ОбщаяСсылка, ОбщийТип = "") Экспорт
	
	Если ТипЗнч(ОбщаяСсылка) <> Тип("Строка") И ОбщаяСсылка.Пустая() Тогда
		Возврат Новый(ПолучитьТипРазделенныхДанныхПоОбщему(ТипЗнч(ОбщаяСсылка)));
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СвязиПоставляемыхДанных.ЭлементРазделенныхДанных КАК Ссылка
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|ГДЕ
	|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
	|	И СвязиПоставляемыхДанных.ЭлементОбщихДанных = &ЭлементОбщихДанных
	|   И СвязиПоставляемыхДанных.ТипОбщихДанных = &ТипОбщихДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	Запрос.УстановитьПараметр("ЭлементОбщихДанных", ОбщаяСсылка);
	Запрос.УстановитьПараметр("ТипОбщихДанных", ОбщийТип);
	
	УстановитьПривилегированныйРежим(Истина);
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Результат.Пустой() Тогда
		Текст = НСтр("ru = 'Не найдена разделенная ссылка соответствующая общей: %ОбщаяСсылка%'");
		Текст = СтрЗаменить(Текст, "%ОбщаяСсылка%", ОбщаяСсылка);
		ВызватьИсключение(Текст);
	КонецЕсли;
	
	Возврат Результат.Выгрузить()[0].Ссылка;
	
КонецФункции

Функция ПреобразоватьОбщееЗначениеВРазделенное(Знач ИсходноеЗначение) Экспорт
	
	ТипИсходногоЗначения = ТипЗнч(ИсходноеЗначение);
	
	СоответствиеТипов = ПоставляемыеДанныеПовтИсп.СоответствиеТиповРазделенныхДанныхОбщим();
	Если СоответствиеТипов.Получить(ТипИсходногоЗначения) <> Неопределено Тогда
		Возврат РазделеннаяСсылкаПоОбщей(ИсходноеЗначение);
	Иначе
		Возврат ИсходноеЗначение;
	КонецЕсли;
	
КонецФункции

Функция ЗаменитьОбщиеСсылкиРазделеннымиВТаблице(Знач ИсходнаяТаблица) Экспорт
	
	РезультирующаяТаблица = Новый ТаблицаЗначений;
	Для каждого КолонкаТаблицы Из ИсходнаяТаблица.Колонки Цикл
		РезультирующаяТаблица.Колонки.Добавить(КолонкаТаблицы.Имя);
	КонецЦикла;
	
	Для каждого ИсходнаяСтрока Из ИсходнаяТаблица Цикл
		РезультирующаяСтрока = РезультирующаяТаблица.Добавить();
		Для каждого КолонкаТаблицы Из ИсходнаяТаблица.Колонки Цикл
			РезультирующаяСтрока[КолонкаТаблицы.Имя] = 
				ПреобразоватьОбщееЗначениеВРазделенное(ИсходнаяСтрока[КолонкаТаблицы.Имя]);
		КонецЦикла;
	КонецЦикла;
	
	Возврат РезультирующаяТаблица;
	
КонецФункции

// Функция проверяет необходимость добавления области данных в РС
// ОбластиДляОбновленияПоставляемыхДанных для формирования фоновых заданий
// 
// Параметры:
// ОбластьДанных - Число – область данных для добавления в РС
// НомерЗагрузки - Число - номер загрузки общих данных
//
// Возвращаемое значение:
// Булево - необходимость добавления узла
//
Функция ДобавитьОбластьДанныхВСписокУзлов(ОбластьДанных, НомерЗагрузки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ОбластьДанных = ОбластьДанных;
	МенеджерЗаписи.НомерСообщения = НомерЗагрузки;
	МенеджерЗаписи.Прочитать();
	
	Возврат Не МенеджерЗаписи.Выбран();
	
КонецФункции

// Функция получает вид поставляемых данных по типу
//
// Параметры:
// Тип - тип, по которому определяется вид 
//
// Возвращаемое значение:
// Вид поставляемых данных
//
Функция ПолучитьВидПоставляемыхДанныхПоОбщему(Тип) Экспорт
	
	ТаблицаСоответствия = ОбщегоНазначения.ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим();
	
	НайденнаяСтрока = ТаблицаСоответствия.Найти(Тип, "ТипОбщихДанных");
	Если НайденнаяСтрока = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'Не найдена строка соответствия для типа поставляемых данных %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Тип);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ВидПоставляемыхДанных = НайденнаяСтрока.ВидПоставляемыхДанных;
	
	Возврат ВидПоставляемыхДанных;
	
КонецФункции

// Функция получает тип разделенных данных по типу
//
// Параметры:
// Тип - тип общих данных
//
// Возвращаемое значение:
// Тип - тип разделенных данных
//
Функция ПолучитьТипРазделенныхДанныхПоОбщему(Тип) Экспорт
	
	ТаблицаСоответствия = ОбщегоНазначения.ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим();
	
	НайденнаяСтрока = ТаблицаСоответствия.Найти(Тип, "ТипОбщихДанных");
	Если НайденнаяСтрока = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'Не найдена строка соответствия для типа поставляемых данных %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Тип);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ТипПриемник = НайденнаяСтрока.ТипРазделенныхДанных;
	
	Возврат ТипПриемник;
	
КонецФункции

// Функция получает тип разделенных данных по типу
//
// Параметры:
// Тип - тип разделенных данных
//
// Возвращаемое значение:
// Тип - тип общих данных
//
Функция ПолучитьТипОбщихДанныхПоРазделенному(Тип) Экспорт
	
	ТаблицаСоответствия = ОбщегоНазначения.ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим();
	
	НайденнаяСтрока = ТаблицаСоответствия.Найти(Тип, "ТипРазделенныхДанных");
	Если НайденнаяСтрока = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'Не найдена строка соответствия для типа поставляемых данных %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Тип);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ТипПриемник = НайденнаяСтрока.ТипОбщихДанных;
	
	Возврат ТипПриемник;
	
КонецФункции

// Функция получает версию поставляемых данных
//
// Параметры:
// Тип - тип общих данных
//
// Возвращаемое значение:
// ВерсияПоставляемыхДанных - версия Поставляемых данных
//
Функция ПолучитьВерсиюПоставляемыхДанных(Тип) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВерсииПоставляемыхДанных.ВерсияПоставляемыхДанных
	|ИЗ
	|	РегистрСведений.ВерсииПоставляемыхДанных КАК ВерсииПоставляемыхДанных
	|ГДЕ
	|	ВерсииПоставляемыхДанных.ВидПоставляемыхДанных = &ВидПоставляемыхДанных";
	
	Запрос.УстановитьПараметр("ВидПоставляемыхДанных", ПолучитьВидПоставляемыхДанныхПоОбщему(Тип));
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат РезультатЗапроса.Выгрузить()[0].ВерсияПоставляемыхДанных;
	
КонецФункции

// Процедура копирует список элементов общего справочника в новую область данных
//
// Параметры:
// СписокКодовСправочника - массив - массив кодов справочника
// ТипИсточника           - тип - тип общего справочника,
//                                откуда будут скопированы элементы
//
Процедура СкопироватьЭлементыСправочника(СписокКодовСправочника, ТипИсточника) Экспорт
	
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипИсточника);
	
	Если МетаданныеОбъекта = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'Не найден объект метаданных для справочника: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ТипИсточника);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Текст = 
	"ВЫБРАТЬ
	|	СправочникИсточник.Ссылка,
	|	СправочникИсточник.Код
	|ИЗ
	|	Справочник." + МетаданныеОбъекта.Имя + " КАК СправочникИсточник";
	
	Если ЗначениеЗаполнено(СписокКодовСправочника) Тогда
		Текст = Текст + "
		|ГДЕ
		|	СправочникИсточник.Код В(&СписокКодовСправочника)";
		
		Запрос.УстановитьПараметр("СписокКодовСправочника", СписокКодовСправочника);
	КонецЕсли;
	Запрос.Текст = Текст;
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	МассивКодовСправочника = РезультатЗапроса.ВыгрузитьКолонку("Код");
	
	Если ЗначениеЗаполнено(СписокКодовСправочника)
		И СписокКодовСправочника.Количество() <> МассивКодовСправочника.Количество() Тогда
		Если НЕ ЗначениеЗаполнено(МассивКодовСправочника) Тогда
			
			ШаблонСообщения =
				НСтр("ru = 'Поставляемые данные. При копировании по списку кодов не найдено ни одного элемента в справочнике: %1.'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ШаблонСообщения, МетаданныеОбъекта.Представление());
			ВызватьИсключение(ТекстСообщения);
			
		Иначе
			МассивНеНайденныхКодовСправочника = Новый Массив;
			Счетчик = 0;
			Для Каждого Код Из СписокКодовСправочника Цикл
				Если МассивКодовСправочника.Найти(Код) = Неопределено Тогда
					Если Счетчик <= 20 Тогда
						МассивНеНайденныхКодовСправочника.Добавить(Код);
					КонецЕсли;
					Счетчик = Счетчик + 1;
				КонецЕсли;
			КонецЦикла;
			Если Счетчик > 20 Тогда
				МассивНеНайденныхКодовСправочника.Добавить("...");
			КонецЕсли;
			
			СтрокаРезультат = СтроковыеФункцииКлиентСервер.ПолучитьСтрокуИзМассиваПодстрок(МассивНеНайденныхКодовСправочника);
			
			ШаблонСообщения =
				НСтр("ru = 'Поставляемые данные. При копировании по списку кодов не найдены элементы (%3) с кодами %2 в справочнике: %1.'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ШаблонСообщения, МетаданныеОбъекта.Представление(), СтрокаРезультат, Счетчик);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
	КонецЕсли;
	
	МассивЭлементовСправочника = РезультатЗапроса.ВыгрузитьКолонку("Ссылка");
	ПодобратьИзКлассификатора(МассивЭлементовСправочника);
	
КонецПроцедуры

// При необходимости создает узел для области данных с переданным значеним
// разделителя.
//
// Параметры:
//  ОбластьДанных - Число - значение разделеителя области данных для которой
//   требуется создать узел.
//
Процедура СоздатьУзелОбластиДанных(Знач ОбластьДанных) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИзмененияПоставляемыхДанных.Ссылка КАК Ссылка
	|ИЗ
	|	ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
	|ГДЕ
	|	ИзмененияПоставляемыхДанных.ОбластьДанных = &ОбластьДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбластьДанных);
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		УзелОбъект = ПланыОбмена.ИзмененияПоставляемыхДанных.СоздатьУзел();
		УзелОбъект.ОбластьДанных = ОбластьДанных;
		УзелОбъект.Код = Формат(ОбластьДанных, "ЧН=0; ЧГ=");
		УзелОбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Процедура регистрирует изменения для данных регистра сведений в плане обмена
// 
// Параметры: 
// ЭлементОбщихДанных - искомый элемент общих данных, для данных которого регистрируем изменения
// ИмяРегистраСведений - имя регистра сведений, содержащего измененные данные
// ИмяЭлементаОбщихДанных - имя поля, содержащего ссылку на элемент общих данных
// СтрокаКлючей - перечисленные через запятую имена ключей набора записей
//
// Например:
//  ПоставляемыеДанные.ЗарегистрироватьИзмененияДанныхРегистраСведений(СсылкаОбщихДанных, "ПоставляемыеКурсыВалют", "Валюта", "Период,Валюта");
//
Процедура ЗарегистрироватьИзмененияДанныхРегистраСведений(ЭлементОбщихДанных, ИмяРегистраСведений, ИмяЭлементаОбщихДанных, СтрокаКлючей = "") Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	" + СтрокаКлючей + "
	|ИЗ
	|	РегистрСведений." + ИмяРегистраСведений + "
	|ГДЕ
	|	" + ИмяЭлементаОбщихДанных + " = &" + ИмяЭлементаОбщихДанных;
	
	Запрос.УстановитьПараметр(ИмяЭлементаОбщихДанных, ЭлементОбщихДанных);
	Результат = Запрос.Выполнить();
	
	НаборЗаписей = РегистрыСведений[ИмяРегистраСведений].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор[ИмяЭлементаОбщихДанных].Установить(ЭлементОбщихДанных);
	
	Выборка = Результат.Выбрать();
	
	ИменаКлючей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаКлючей);
	ДанныйУзел = ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(
		ОбщегоНазначения.ЗначениеРазделителяСеанса());
	
	Пока Выборка.Следующий() Цикл
		Для Каждого ИмяКлюча Из ИменаКлючей Цикл
			НаборЗаписей.Отбор[ИмяКлюча].Установить(Выборка[ИмяКлюча]);
		КонецЦикла;
		ПланыОбмена.ЗарегистрироватьИзменения(ДанныйУзел, НаборЗаписей);
	КонецЦикла;
	
КонецПроцедуры

// Процедура обновляет флаг ручного изменения в регистре СвязиПоставляемыхДанных
//
Процедура ОбновитьЗаписьРучногоИзмененияЭлемента(Ссылка, Флаг) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.СвязиПоставляемыхДанных.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
	МенеджерЗаписи.ЭлементОбщихДанных = ОбщаяСсылкаПоРазделенной(Ссылка);
	МенеджерЗаписи.ЭлементРазделенныхДанных = Ссылка;
	МенеджерЗаписи.РучноеИзменение = Флаг;
	МенеджерЗаписи.Записать();
	
КонецПроцедуры

// Процедура принудительно обновляет разделенный элемент справочника данными из общего
// 
// Параметры: 
// Ссылка - ссылка на элемент разделенных данных, который необходимо обновить
//
Процедура ОбновитьЭлементСправочникаИзОбщихДанных(Ссылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПланыОбмена.ЗарегистрироватьИзменения(
		ПоставляемыеДанныеПовтИсп.ПолучитьУзелОбластиДанных(ОбщегоНазначения.ЗначениеРазделителяСеанса()),
		ОбщаяСсылкаПоРазделенной(Ссылка));
	
	ОбновитьПоставляемыеДанные(ОбщегоНазначения.ЗначениеРазделителяСеанса(), 0);
	
КонецПроцедуры

// Процедура формирует в переданном объекте Запрос временную таблицу ВТ_СтарыеКлючи,
// содержащую данные набора записей 
//
// Параметры:
// Запрос - объект запрос, в менеджере временных таблиц которого формируется таблица данных регистра
// НаборЗаписей - набор записей регистра сведений
// СтрокаКлючей - перечисленные через запятую имена ключей набора записей
//
// Пример:
//   СформироватьВременнуюТаблицуДанныхНабораЗаписей(Запрос, ЭтотОбъект, "Период, Валюта"); 
//
Процедура СформироватьВременнуюТаблицуДанныхНабораЗаписей(Запрос, НаборЗаписей, СтрокаКлючей = "") Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	" + СтрокаКлючей + "
	|ПОМЕСТИТЬ ВТ_СтарыеКлючи
	|ИЗ
	|	РегистрСведений." + НаборЗаписей.Метаданные().Имя;
	
	ТекстУсловия = "";
	Для каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если НЕ ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ТекстУсловия) Тогда
			ТекстУсловия = ТекстУсловия + Символы.ПС + Символы.Таб + "И ";
		КонецЕсли;
		
		ТекстУсловия = ТекстУсловия + ЭлементОтбора.Имя + " = &" + ЭлементОтбора.Имя;
		Запрос.УстановитьПараметр(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстУсловия) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|	" + ТекстУсловия;
	КонецЕсли;
	
	Запрос.Выполнить();
	
КонецПроцедуры

// Процедура регистрирует изменения данных набора записей регистра сведений в плане обмена
//
// Запрос - объект запрос, в менеджере временных таблиц которого сформирована временная таблица данных регистра до изменения
// НаборЗаписей - набор записей регистра сведений
// ИмяЭлементаОбщихДанных - имя поля, содержащего ссылку на элемент общих данных
// СтрокаКлючей - перечисленные через запятую имена ключей набора записей
// ИгнорироватьРучныеИзменения - признак необходимости регистрировать изменения для данных, подчиненных измененному вручную объекту
//
Процедура ЗарегистрироватьИзмененияДанныхНабораЗаписей(Запрос, НаборЗаписей, ИмяЭлементаОбщихДанных, СтрокаКлючей = "", ИгнорироватьРучныеИзменения = Ложь, ТипОбщихДанных = "") Экспорт
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВТ_СтарыеКлючи", "ВТ_НовыеКлючи");
	Запрос.Выполнить();
	
	//Выбираем области данных (и узлы плана ИзмененияПоставляемыхДанных), связанные через
	//регистр СвязиПоставляемыхДанных с изменившимися общими данными
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	" + СтрокаКлючей + "
	|ПОМЕСТИТЬ Ключи
	|ИЗ
	|	ВТ_СтарыеКлючи
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	" + СтрокаКлючей + "
	|ИЗ
	|	ВТ_НовыеКлючи
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	" + СтрокаКлючей + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Ключи.*,
	|	ИзмененияПоставляемыхДанных.Ссылка КАК Узел,
	|	СвязиПоставляемыхДанных.ОбластьДанных КАК ОбластьДанных
	|ИЗ
	|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Ключи КАК Ключи
	|		ПО СвязиПоставляемыхДанных.ЭлементОбщихДанных = Ключи." + ИмяЭлементаОбщихДанных + "
	|           И СвязиПоставляемыхДанных.ТипОбщихДанных = &ТипОбщихДанных 
	|			И (&ИгнорироватьРучныеИзменения ИЛИ НЕ СвязиПоставляемыхДанных.РучноеИзменение)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
	|		ПО СвязиПоставляемыхДанных.ОбластьДанных = ИзмененияПоставляемыхДанных.ОбластьДанных
	|
	|УПОРЯДОЧИТЬ ПО
	|	" + СтрокаКлючей;
	
	Если НаборЗаписей.ДополнительныеСвойства.Свойство("НомерЗагрузки") Тогда
		НомерЗагрузки = НаборЗаписей.ДополнительныеСвойства.НомерЗагрузки;
	Иначе
		НомерЗагрузки = Константы.НомерЗагрузкиПоставляемыхДанных.Получить();
	КонецЕсли;
	
	Области = Новый Соответствие;
	
	Запрос.УстановитьПараметр("ИгнорироватьРучныеИзменения", ИгнорироватьРучныеИзменения);
	Запрос.УстановитьПараметр("ТипОбщихДанных", ТипОбщихДанных);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	ТекущийКлюч = Новый Структура(СтрокаКлючей);
	НакопленныеУзлы = Новый Массив;
	
	НаборДляРегистрации = РегистрыСведений[НаборЗаписей.Метаданные().Имя].СоздатьНаборЗаписей();
	
	Пока Выборка.Следующий() Цикл
		Если Области.Получить(Выборка.ОбластьДанных) = Неопределено Тогда
			Области.Вставить(Выборка.ОбластьДанных, Истина);
			
			//Помечаем область данных как подлежащую обновлению
			Если ДобавитьОбластьДанныхВСписокУзлов(Выборка.ОбластьДанных, НомерЗагрузки) Тогда
				Менеджер = РегистрыСведений.ОбластиДляОбновленияПоставляемыхДанных.СоздатьМенеджерЗаписи();
				Менеджер.ОбластьДанных = Выборка.ОбластьДанных;
				Менеджер.НомерСообщения = НомерЗагрузки;
				Менеджер.Записать();
			КонецЕсли;
		КонецЕсли;
		
		ОтличаетсяКлюч = Ложь;
		Для каждого КлючИЗначение Из ТекущийКлюч Цикл
			Если Выборка[КлючИЗначение.Ключ] <> КлючИЗначение.Значение Тогда
				ОтличаетсяКлюч = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		//Если мы дошли до следующей записи в СвязиПоставляемыхДанных - регистрируем
		//изменения для всех подходящих областей данных
		Если ОтличаетсяКлюч Тогда
			Если НакопленныеУзлы.Количество() > 0 Тогда
				Для каждого КлючИЗначение Из ТекущийКлюч Цикл
					НаборДляРегистрации.Отбор[КлючИЗначение.Ключ].Установить(КлючИЗначение.Значение);
				КонецЦикла;
				ПланыОбмена.ЗарегистрироватьИзменения(НакопленныеУзлы, НаборДляРегистрации);
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(ТекущийКлюч, Выборка);
			НакопленныеУзлы = Новый Массив;
		КонецЕсли;
		
		НакопленныеУзлы.Добавить(Выборка.Узел);
		
	КонецЦикла;
	
	Если НакопленныеУзлы.Количество() > 0 Тогда
		Для каждого КлючИЗначение Из ТекущийКлюч Цикл
			НаборДляРегистрации.Отбор[КлючИЗначение.Ключ].Установить(КлючИЗначение.Значение);
		КонецЦикла;
		ПланыОбмена.ЗарегистрироватьИзменения(НакопленныеУзлы, НаборДляРегистрации);
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////////////
// Процедуры обслуживания флага РучноеИзменение в формах разделенных поставляемых данных
//
// Единственным параметром всех процедур является Форма - УправляемаяФорма элемента.
// В форме должны присутствовать следующие реквизиты:
//  Объект - объект разделнный поставляемых данных
//  РучноеИзменение - Произвольный - состяние разделенного объекта
//   относительно общего. Реквизит не должен выводиться на форму.
//  ТекстРучногоИзменения - Строка, 0 - текст надписи отображающей
//   состояние разделенного объекта относительно общего.
// В форме должны присутствовать следующие кнопки:
//  ОбновитьИзКлассификатора
//  Изменить
//

// Считывает текущее состояние разделенного объекта и приводит форму
// в соответстие с ним
//
Процедура СчитатьФлагРучногоИзменения(Знач Форма) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	СвязиПоставляемыхДанных.РучноеИзменение
		|ИЗ
		|	РегистрСведений.СвязиПоставляемыхДанных КАК СвязиПоставляемыхДанных
		|ГДЕ
		|	СвязиПоставляемыхДанных.ОбластьДанных = &ОбластьДанных
		|	И СвязиПоставляемыхДанных.ЭлементРазделенныхДанных = &ЭлементРазделенныхДанных";
		Запрос.УстановитьПараметр("ОбластьДанных", ОбщегоНазначения.ЗначениеРазделителяСеанса());
		Запрос.УстановитьПараметр("ЭлементРазделенныхДанных", Форма.Объект.Ссылка);
		
		УстановитьПривилегированныйРежим(Истина);
		РезультатЗапроса = Запрос.Выполнить();
		УстановитьПривилегированныйРежим(Ложь);
		
		Если РезультатЗапроса.Пустой() Тогда
			
			Форма.РучноеИзменение = Неопределено;
			
		Иначе
			
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Форма.РучноеИзменение = Выборка.РучноеИзменение;
			
		КонецЕсли;
		
		ПоставляемыеДанныеКлиентСервер.ОбработатьФлагРучногоИзменения(Форма);
		
	КонецЕсли;
	
КонецПроцедуры

// Записывает состояние разделенного объекта
//
Процедура ЗаписатьФлагРучногоИзменение(Знач Форма) Экспорт
	
	Если Форма.РучноеИзменение = Истина Тогда
		ОбновитьЗаписьРучногоИзмененияЭлемента(Форма.Объект.Ссылка, Истина);
	КонецЕсли;
	
КонецПроцедуры

// Копирует данные общего объекта в разделенный и изменяет
// состояние разделенного объекта
//
Процедура ВосстановитьЭлементИзОбщихДанных(Знач Форма) Экспорт
	
	НачатьТранзакцию();
	Попытка
		Ссылки = Новый Массив;
		Ссылки.Добавить(ОбщаяСсылкаПоРазделенной(Форма.Объект.Ссылка));
		ПодобратьИзКлассификатора(Ссылки, Истина);
		
		ОбновитьЗаписьРучногоИзмененияЭлемента(Форма.Объект.Ссылка, Ложь);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Восстановление из общих данных'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Форма.Прочитать();
	
КонецПроцедуры

// Удаляет служебные записи поставляемых данных при удалении области
//
Процедура ПриУдаленииОбластиДанных(Знач ОбластьДанных) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИзмененияПоставляемыхДанных.Ссылка КАК Ссылка
	|ИЗ
	|	ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
	|ГДЕ
	|	ИзмененияПоставляемыхДанных.ОбластьДанных = &ОбластьДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбластьДанных);
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	Удаление = Новый УдалениеОбъекта(Результат.Выгрузить()[0][0]);
	Удаление.ОбменДанными.Загрузка = Истина;
	Удаление.Записать();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ДополнитьМассивРодителямиСсылок(Знач Ссылки)
	
	ИмяТаблицы = Ссылки[0].Метаданные().ПолноеИмя();
	
	МассивСсылок = Новый Массив;
	Для каждого Ссылка Из Ссылки Цикл
		МассивСсылок.Добавить(Ссылка);
	КонецЦикла;
	
	ТекущиеСсылки = Ссылки;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Таблица.Родитель КАК Ссылка
	|ИЗ
	|	" + ИмяТаблицы + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка В (&Ссылки)
	|	И Таблица.Родитель <> ЗНАЧЕНИЕ(" + ИмяТаблицы + ".ПустаяСсылка)";
	
	Пока Истина Цикл
		Запрос.УстановитьПараметр("Ссылки", ТекущиеСсылки);
		Результат = Запрос.Выполнить();
		Если Результат.Пустой() Тогда
			Прервать;
		КонецЕсли;
		
		ТекущиеСсылки = Новый Массив;
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			ТекущиеСсылки.Добавить(Выборка.Ссылка);
			МассивСсылок.Добавить(Выборка.Ссылка);
		КонецЦикла;
	КонецЦикла;
	
	Возврат МассивСсылок;
	
КонецФункции

Процедура СкопироватьОбъектИзЭталона(Эталон, МетаданныеИсточника, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник)
	
	СсылкаРезультата = РазделеннаяСсылкаПоОбщей(Эталон.Ссылка);
	
	МетаданныеПриемника = СсылкаРезультата.Метаданные();
	
	ИерархическийСправочник = МетаданныеПриемника.Иерархический И МетаданныеИсточника.Иерархический;
	
	Результат = СсылкаРезультата.ПолучитьОбъект();
	Если Результат = Неопределено Тогда
		Если ИерархическийСправочник И Эталон.ЭтоГруппа Тогда
			Результат = Менеджер.СоздатьГруппу();
		Иначе
			Результат = Менеджер.СоздатьЭлемент();
		КонецЕсли;
		Результат.УстановитьСсылкуНового(СсылкаРезультата);
	КонецЕсли;
	Результат.ОбменДанными.Загрузка = Истина;
	
	Если МетаданныеПриемника.ДлинаНаименования > 0 
		И МетаданныеИсточника.ДлинаНаименования > 0 Тогда
		Результат.Наименование = Эталон.Наименование;
	КонецЕсли;
	
	Если МетаданныеПриемника.ДлинаКода > 0
		И МетаданныеИсточника.ДлинаКода > 0 Тогда
		Результат.Код = Эталон.Код;
	КонецЕсли;
	
	Если ИерархическийСправочник Тогда
		Результат.Родитель = ПреобразоватьОбщееЗначениеВРазделенное(Эталон.Родитель);
	КонецЕсли;
	
	ИерархияГрупп = МетаданныеПриемника.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;
	
	Для Каждого МДРеквизита Из МетаданныеПриемника.Реквизиты Цикл
		Если НЕ ИерархияГрупп
			ИЛИ МДРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
			ИЛИ МДРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы
			И Эталон.ЭтоГруппа
			ИЛИ МДРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента
			И НЕ Эталон.ЭтоГруппа Тогда
			
			Если МетаданныеИсточника.Реквизиты.Найти(МДРеквизита.Имя) <> Неопределено Тогда
				Результат[МДРеквизита.Имя] = ПреобразоватьОбщееЗначениеВРазделенное(Эталон[МДРеквизита.Имя]);
			Иначе
				Результат[МДРеквизита.Имя] = Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого МДТабличнойЧасти Из МетаданныеПриемника.ТабличныеЧасти Цикл
		Если НЕ ИерархияГрупп
			ИЛИ МДТабличнойЧасти.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
			ИЛИ МДТабличнойЧасти.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы
			И Эталон.ЭтоГруппа
			ИЛИ МДТабличнойЧасти.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента
			И НЕ Эталон.ЭтоГруппа Тогда
			
			Если МетаданныеИсточника.ТабличныеЧасти.Найти(МДТабличнойЧасти.Имя) <> Неопределено Тогда
				Результат[МДТабличнойЧасти.Имя].Загрузить(
					ЗаменитьОбщиеСсылкиРазделеннымиВТаблице(Эталон[МДТабличнойЧасти.Имя].Выгрузить()));
			Иначе
				Результат[МДТабличнойЧасти.Имя].Очистить();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ОбъектПриемник = Результат;
	
КонецПроцедуры

Процедура СкопироватьНаборЗаписейИзЭталона(Эталон, МетаданныеОбъекта, Менеджер, ТипИсточника, ТипПриемника, ОбъектПриемник)
	
	Результат = Менеджер.СоздатьНаборЗаписей();
	
	Для Каждого ЭлементОтбора Из Эталон.Отбор Цикл
		Если НЕ ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		Результат.Отбор[ЭлементОтбора.Имя].Установить(ПреобразоватьОбщееЗначениеВРазделенное(ЭлементОтбора.Значение));
	КонецЦикла;
	
	Результат.ОбменДанными.Загрузка = Истина;
	
	Результат.Загрузить(ЗаменитьОбщиеСсылкиРазделеннымиВТаблице(Эталон.Выгрузить()));
	
	ОбъектПриемник = Результат;
	
КонецПроцедуры

Процедура ЗагрузитьДанные(Results, НомерЗагрузки)
	
	ДвоичныеДанные = Results.Data;
	СоответствиеВерсийПоставляемыхДанных = ПолучитьСоответствиеВерсийПоставляемыхДанных(Results.SuppliedData);
	
	ИмяАрхива = ПолучитьИмяВременногоФайла("zip");
	ДвоичныеДанные.Записать(ИмяАрхива);
	
	ПутьКФайлу = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(ПутьКФайлу);
	
	Разархиватор = Новый ЧтениеZipФайла(ИмяАрхива);
	Разархиватор.Извлечь(Разархиватор.Элементы[0], ПутьКФайлу);
	Разархиватор.Закрыть();
	
	Файлы = НайтиФайлы(ПутьКФайлу, "*");
	Если Файлы.Количество() > 0 Тогда
		ЧтениеXML = Новый ЧтениеFastInfoset;
		Попытка
			ЧтениеXML.ОткрытьФайл(Файлы[0].ПолноеИмя);
			
			СтароеИмяУзла = "";
			Пока ЧтениеXML.Прочитать() Цикл
				ИмяУзла = ЧтениеXML.ЛокальноеИмя;
				
				Если Найти(ИмяУзла, "CatalogObject.") = 1 Тогда
					ЗагрузитьЭлементСправочника(ЧтениеXML, НомерЗагрузки);
				ИначеЕсли Найти(ИмяУзла, "InformationRegisterRecordSet.") = 1 Тогда
					ЗагрузитьНаборЗаписейРегистраСведений(ЧтениеXML, НомерЗагрузки);
				КонецЕсли;
				
				Если Найти(ИмяУзла, "CatalogObject.") = 1 ИЛИ Найти(ИмяУзла, "InformationRegisterRecordSet.") = 1 Тогда
					Если ИмяУзла <> СтароеИмяУзла Тогда
						ЗаписатьВерсиюПоставляемыхДанных(СтароеИмяУзла, СоответствиеВерсийПоставляемыхДанных);
						СтароеИмяУзла = ИмяУзла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			ЗаписатьВерсиюПоставляемыхДанных(СтароеИмяУзла, СоответствиеВерсийПоставляемыхДанных);
			
			ЧтениеXML.Закрыть();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка поставляемых данных'"), УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Попытка
				ЧтениеXML.Закрыть();
				УдалитьФайлы(ИмяАрхива);
				УдалитьФайлы(ПутьКФайлу);
			Исключение
			КонецПопытки;
			ВызватьИсключение(ТекстОшибки);
		КонецПопытки;
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяАрхива);
		УдалитьФайлы(ПутьКФайлу);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

Процедура ЗагрузитьЭлементСправочника(ДанныеДляЧтения, НомерЗагрузки)
	
	ИмяУзла = ДанныеДляЧтения.ЛокальноеИмя;
	
	ИмяСправочника = ПоставляемыеДанныеПовтИсп.ПолучитьИмяСправочникаПоИмениУзла(ИмяУзла);
	
	ЗначенияРеквизитов = Новый Структура;
	ТипыРеквизитов = ПоставляемыеДанныеПовтИсп.ПолучитьТипыРеквизитовСправочникаПоИмениУзла(ИмяУзла);
	Для Каждого СтрокаСписка Из ТипыРеквизитов Цикл
		Если ТипЗнч(СтрокаСписка.Значение.Тип) = Тип("Соответствие") Тогда
			ТаблицаЗначенийВложенногоРеквизита = Новый ТаблицаЗначений;
			Для Каждого СтрокаВложенногоСписка Из СтрокаСписка.Значение.Тип Цикл 
				ТаблицаЗначенийВложенногоРеквизита.Колонки.Добавить(СтрокаВложенногоСписка.Ключ);
			КонецЦикла;
			ЗначенияРеквизитов.Вставить(СтрокаСписка.Ключ, ТаблицаЗначенийВложенногоРеквизита);
		Иначе
			ЗначенияРеквизитов.Вставить(СтрокаСписка.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	ДанныеДляЧтения.Прочитать();
	Пока ДанныеДляЧтения.ЛокальноеИмя <> ИмяУзла Цикл
		Если ДанныеДляЧтения.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			ТипЗначения = ДанныеДляЧтения.ЗначениеАтрибута("xsi:type");
			ЛокальноеИмя = ДанныеДляЧтения.ЛокальноеИмя;
			
			ДанныеДляЧтения.Прочитать();
			Если ЗначенияРеквизитов.Свойство(ЛокальноеИмя) Тогда
				Если ТипЗнч(ЗначенияРеквизитов[ЛокальноеИмя]) <> Тип("ТаблицаЗначений") Тогда
					Если ДанныеДляЧтения.ИмеетЗначение Тогда
						Если ЗначенияРеквизитов.Свойство(ЛокальноеИмя) Тогда
							Если ТипЗначения = Неопределено Тогда
								Значение = XMLЗначение(ТипыРеквизитов[ЛокальноеИмя].Тип, ДанныеДляЧтения.Значение);
							Иначе
								Значение = XMLЗначение(ИзXMLТипа(ТипЗначения), ДанныеДляЧтения.Значение);
							КонецЕсли;
							ЗначенияРеквизитов[ЛокальноеИмя] = Значение;
						КонецЕсли;
					КонецЕсли;
				Иначе
					ИмяТаблицы = ЛокальноеИмя;
					Пока ДанныеДляЧтения.ЛокальноеИмя <> ИмяТаблицы Цикл
						Если ДанныеДляЧтения.ТипУзла = ТипУзлаXML.НачалоЭлемента 
							И ДанныеДляЧтения.ЛокальноеИмя = "Row" Тогда
							НоваяСтрока = ЗначенияРеквизитов[ИмяТаблицы].Добавить();
							ДанныеДляЧтения.Прочитать();
						КонецЕсли;
						Пока ДанныеДляЧтения.ЛокальноеИмя <> "Row" Цикл
							ТипЗначения = ДанныеДляЧтения.ЗначениеАтрибута("xsi:type");							
							ЛокальноеИмя = ДанныеДляЧтения.ЛокальноеИмя;
							
							ДанныеДляЧтения.Прочитать();
							Если ДанныеДляЧтения.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
								ДанныеДляЧтения.Прочитать();
								Продолжить;								
							КонецЕсли;
							Если ТипЗначения = Неопределено Тогда
								Значение = XMLЗначение(ТипыРеквизитов[ИмяТаблицы].Тип[ЛокальноеИмя], ДанныеДляЧтения.Значение);
							Иначе
								Значение = XMLЗначение(ИзXMLТипа(ТипЗначения), ДанныеДляЧтения.Значение);
							КонецЕсли;
							НоваяСтрока[ЛокальноеИмя] = Значение;	
							ДанныеДляЧтения.Прочитать();
							ДанныеДляЧтения.Прочитать();
						КонецЦикла;		
						ДанныеДляЧтения.Прочитать();
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		ДанныеДляЧтения.Прочитать();
	КонецЦикла;
	
	СправочникОбъект = ЗначенияРеквизитов["Ссылка"].ПолучитьОбъект();
	Если СправочникОбъект = Неопределено Тогда
		Если ЗначенияРеквизитов.Свойство("ЭтоГруппа") И ЗначенияРеквизитов.ЭтоГруппа Тогда
			СправочникОбъект = Справочники[ИмяСправочника].СоздатьГруппу();
		Иначе
			СправочникОбъект = Справочники[ИмяСправочника].СоздатьЭлемент();
		КонецЕсли;
		СправочникОбъект.УстановитьСсылкуНового(ЗначенияРеквизитов["Ссылка"]);
	КонецЕсли;
	Для Каждого ЗначениеРеквизита Из ЗначенияРеквизитов Цикл
		Если ЗначениеРеквизита.Ключ = "ЭтоГруппа"
			ИЛИ ЗначениеРеквизита.Ключ = "Предопределенный"
			ИЛИ ЗначениеРеквизита.Ключ = "Ссылка" Тогда
			Продолжить;
		КонецЕсли;	
		Если ТипЗнч(ЗначениеРеквизита.Значение) = Тип("ТаблицаЗначений") Тогда
			Если ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
				ИЛИ ЗначенияРеквизитов.ЭтоГруппа
				И ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы
				ИЛИ Не ЗначенияРеквизитов.ЭтоГруппа
				И ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
				СправочникОбъект[ЗначениеРеквизита.Ключ].Загрузить(ЗначениеРеквизита.Значение);
			КонецЕсли;
		Иначе
			Если Не ЗначенияРеквизитов.Свойство("ЭтоГруппа") Тогда
				СправочникОбъект[ЗначениеРеквизита.Ключ] = ЗначениеРеквизита.Значение;
			Иначе
				Если ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента
					ИЛИ ЗначенияРеквизитов.ЭтоГруппа
					И ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы
					ИЛИ Не ЗначенияРеквизитов.ЭтоГруппа
					И ТипыРеквизитов[ЗначениеРеквизита.Ключ].ИспользованиеРеквизита = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента Тогда
					СправочникОбъект[ЗначениеРеквизита.Ключ] = ЗначениеРеквизита.Значение;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	СправочникОбъект.ДополнительныеСвойства.Вставить("НомерЗагрузки", НомерЗагрузки);
	СправочникОбъект.Записать();
	
КонецПроцедуры

Процедура ЗагрузитьНаборЗаписейРегистраСведений(ДанныеДляЧтения, НомерЗагрузки)
	
	ИмяУзлаНабора = ДанныеДляЧтения.ЛокальноеИмя;
	
	ИмяРегистра = ПоставляемыеДанныеПовтИсп.ПолучитьИмяРегистраСведенийПоИмениУзла(ИмяУзлаНабора);
	ЗначенияРеквизитов = Новый Структура;
	ТипыРеквизитов = ПоставляемыеДанныеПовтИсп.ПолучитьТипыРеквизитовРегистраСведенийПоИмениУзла(ИмяУзлаНабора);
	Для Каждого СтрокаСписка Из ТипыРеквизитов Цикл
		ЗначенияРеквизитов.Вставить(СтрокаСписка.Ключ);
		ТипыРеквизитов.Вставить(СтрокаСписка.Ключ, СтрокаСписка.Значение);
	КонецЦикла;
	
	ДанныеДляЧтения.Прочитать();
	НовыйНаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
	Пока ДанныеДляЧтения.ЛокальноеИмя <> ИмяУзлаНабора Цикл
		Если ДанныеДляЧтения.ЛокальноеИмя = "Filter" Тогда
			ИмяУзла = ДанныеДляЧтения.ЛокальноеИмя;
			ДанныеДляЧтения.Прочитать();
			Пока ДанныеДляЧтения.ЛокальноеИмя <> ИмяУзла Цикл
				Если ДанныеДляЧтения.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					ТипЗначения  = ДанныеДляЧтения.ЗначениеАтрибута("xsi:type");
					ЛокальноеИмя = ДанныеДляЧтения.ЛокальноеИмя;
					ДанныеДляЧтения.Прочитать();
					Если ТипЗначения = Неопределено Тогда
						Значение = XMLЗначение(ТипыРеквизитов[ЛокальноеИмя], ДанныеДляЧтения.Значение);
					Иначе
						Значение = XMLЗначение(ИзXMLТипа(ТипЗначения), ДанныеДляЧтения.Значение);
					КонецЕсли;
					Если НовыйНаборЗаписей.Отбор.Найти(ЛокальноеИмя) <> Неопределено Тогда
						НовыйНаборЗаписей.Отбор[ЛокальноеИмя].Установить(Значение);
					КонецЕсли;
				КонецЕсли;
				ДанныеДляЧтения.Прочитать();
			КонецЦикла;
			ДанныеДляЧтения.Прочитать();
		КонецЕсли;
		Если Найти(ДанныеДляЧтения.ЛокальноеИмя, "InformationRegisterRecord.") = 1 Тогда
			ИмяУзла = ДанныеДляЧтения.ЛокальноеИмя;
			ДанныеДляЧтения.Прочитать();
			Пока ДанныеДляЧтения.ЛокальноеИмя <> ИмяУзла Цикл
				Если ДанныеДляЧтения.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					ТипЗначения  = ДанныеДляЧтения.ЗначениеАтрибута("xsi:type");
					ЛокальноеИмя = ДанныеДляЧтения.ЛокальноеИмя;
					ДанныеДляЧтения.Прочитать();
					Если ТипЗначения = Неопределено Тогда
						ТипДанных = ТипыРеквизитов[ЛокальноеИмя];
						Значение = XMLЗначение(ТипДанных, ДанныеДляЧтения.Значение);
					Иначе
						Значение = XMLЗначение(ИзXMLТипа(ТипЗначения), ДанныеДляЧтения.Значение);
					КонецЕсли;
					Если ЗначенияРеквизитов.Свойство(ЛокальноеИмя) Тогда
						ЗначенияРеквизитов[ЛокальноеИмя] = Значение;
					КонецЕсли;
				КонецЕсли;
				ДанныеДляЧтения.Прочитать();
			КонецЦикла;
			ДанныеДляЧтения.Прочитать();
			
			НоваяЗапись = НовыйНаборЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, ЗначенияРеквизитов);
		Иначе
			ДанныеДляЧтения.Прочитать();
		КонецЕсли;
	КонецЦикла;
	
	НовыйНаборЗаписей.ДополнительныеСвойства.Вставить("НомерЗагрузки", НомерЗагрузки);
	НовыйНаборЗаписей.Записать();
	
КонецПроцедуры

Функция ПолучитьСоответствиеВерсийПоставляемыхДанных(TableSuppliedData)
	
	СоответствиеВерсийПоставляемыхДанных = Новый Соответствие;
	
	Для каждого SuppliedData Из TableSuppliedData Цикл
		СоответствиеВерсийПоставляемыхДанных.Вставить(SuppliedData.Type, SuppliedData.Version);
	КонецЦикла;
	
	Возврат СоответствиеВерсийПоставляемыхДанных;
	
КонецФункции

Процедура ЗаписатьВерсиюПоставляемыхДанных(СтароеИмяУзла, СоответствиеВерсийПоставляемыхДанных)
	
	Если СтароеИмяУзла = "" Тогда
		Возврат;
	КонецЕсли;
	
	РазложенноеИмяУзла = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтароеИмяУзла, ".");
	
	Если РазложенноеИмяУзла[0] = "CatalogObject" Тогда
		ВидПоставляемыхДанных = "Справочник_" + РазложенноеИмяУзла[1];
	ИначеЕсли РазложенноеИмяУзла[0] = "InformationRegisterRecordSet" Тогда
		ВидПоставляемыхДанных = "РегистрСведений_" + РазложенноеИмяУзла[1];
	КонецЕсли;
	
	Если ВидПоставляемыхДанных = Неопределено Тогда
		ШаблонСообщения = НСтр("ru = 'При загрузке поставляемых данных из сервиса не определен вид для объекта: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, РазложенноеИмяУзла[1]);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	МенеджерЗаписи                          = РегистрыСведений.ВерсииПоставляемыхДанных.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ВидПоставляемыхДанных    = Перечисления.ВидыПоставляемыхДанных[ВидПоставляемыхДанных];
	МенеджерЗаписи.ВерсияПоставляемыхДанных = СоответствиеВерсийПоставляемыхДанных.Получить(ВидПоставляемыхДанных);
	МенеджерЗаписи.Записать();
	
КонецПроцедуры

Функция НовыйПроксиНаМенеджереСервиса()
	
	URL = Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	ИмяПользователя = Константы.ИмяСлужебногоПользователяМенеджераСервиса.Получить();
	ПарольПользователя = Константы.ПарольСлужебногоПользователяМенеджераСервиса.Получить();

	АдресСервиса = URL + "/ws/SuppliedData?wsdl";
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(АдресСервиса, 
		"http://www.1c.ru/SaaS/1.0/WS", "SuppliedData", , ИмяПользователя, ПарольПользователя);
		
КонецФункции
	
////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Добавляет в список Обработчики процедуры-обработчики обновления,
// необходимые данной подсистеме.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                   общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ЗарегистрироватьОбработчикиОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "1.1.3.6";
	Обработчик.Процедура = "ПоставляемыеДанные.ИнициализацияПоставляемыхДанныхОбщиеДанные";
	Обработчик.ОбщиеДанные = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "1.1.3.6";
	Обработчик.Процедура = "ПоставляемыеДанные.ИнициализацияПоставляемыхДанных";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.0.1.10";
	Обработчик.Процедура = "ПоставляемыеДанные.ЗаполнитьНаименованияПоКодам";
	Обработчик.ОбщиеДанные = Истина;
	
КонецПроцедуры	

// Процедура инициализирует поставляемые данные
//
Процедура ИнициализацияПоставляемыхДанных() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		ОбластьДанных = ОбщегоНазначения.ЗначениеРазделителяСеанса();
		
		СоздатьУзелОбластиДанных(ОбластьДанных);
		
		ТаблицаСоответствия = ОбщегоНазначения.ПолучитьТаблицуСоответствияРазделенныхДанныхОбщим();
		Для каждого Строка Из ТаблицаСоответствия Цикл
			
			Если Строка.КопироватьВоВсеОбластиДанных = Истина Тогда
				СписокЭлементов = Новый Массив;
				СкопироватьЭлементыСправочника(СписокЭлементов, Строка.ТипОбщихДанных);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура инициализирует поставляемые данные
//
Процедура ИнициализацияПоставляемыхДанныхОбщиеДанные() Экспорт
	
	ЭтотУзел = ПланыОбмена.ИзмененияПоставляемыхДанных.ЭтотУзел().ПолучитьОбъект();
	ЭтотУзел.ОбластьДанных = -1;
	ЭтотУзел.Код = "-1";
	ЭтотУзел.Записать();
	
КонецПроцедуры

// Процедура обновления для плана обмена ИзмененияПоставляемыхДанных.
// Копирует значения стандартного реквизита Код в Наименование, если последний не заполнен.
// 
Процедура ЗаполнитьНаименованияПоКодам() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ИзмененияПоставляемыхДанных.Ссылка,
		|	ИзмененияПоставляемыхДанных.Код
		|ИЗ
		|	ПланОбмена.ИзмененияПоставляемыхДанных КАК ИзмененияПоставляемыхДанных
		|ГДЕ
		|	ИзмененияПоставляемыхДанных.Наименование = """"";
	Выборка = Запрос.Выполнить().Выбрать();

	Пока Выборка.Следующий() Цикл
		ПланОбменаОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ПланОбменаОбъект.Наименование = ПланОбменаОбъект.Код;
		ПланОбменаОбъект.Записать();
	КонецЦикла;

КонецПроцедуры	

//Получить запрос, возвращающий ссылки на данные с указанными характеристиками
//
// Параметры
//  ВидДанных      - строка.
//  Характеристики - коллекция, содержащая структуры Код(строка)
//                   и Значение(строка)
//
// Возвращаемое значение:
//   Запрос
Функция ЗапросДанныхПоИменам(Знач ВидДанных, Знач Характеристики)
	Если Характеристики = Неопределено Или Характеристики.Количество() = 0 Тогда
		Возврат ЗапросПоИмениВидаДанных(ВидДанных);
	Иначе
		Возврат ЗапросПоИменамХарактеристик(ВидДанных, Характеристики);
	КонецЕсли;
КонецФункции

Функция ЗапросПоИмениВидаДанных(Знач ВидДанных)
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	ПоставляемыеДанные.Ссылка КАК ПоставляемыеДанные
	|ИЗ
	|	Справочник.ПоставляемыеДанные КАК ПоставляемыеДанные
	|ГДЕ
	|	ПоставляемыеДанные.ВидДанных = &ВидДанных";
	Запрос.УстановитьПараметр("ВидДанных", ВидДанных);
	Возврат Запрос;
	
КонецФункции

Функция ЗапросПоИменамХарактеристик(Знач ВидДанных, Знач Характеристики)
//ВЫБРАТЬ Ссылка 
//ИЗ Характеристики 
//ГДЕ (ИмяХарактеристики = '' И ЗначениеХарактеристики = '') ИЛИ ..(N)
//СГРУППИРОВАТЬ ПО ДанныеИд
//ИМЕЮЩИЕ Количество(*) = N	
	Запрос = Новый Запрос();
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПоставляемыеДанныеХарактеристикиДанных.Ссылка КАК ПоставляемыеДанные
	|ИЗ
	|	Справочник.ПоставляемыеДанные.ХарактеристикиДанных КАК ПоставляемыеДанныеХарактеристикиДанных
	|ГДЕ 
	|	ПоставляемыеДанныеХарактеристикиДанных.Ссылка.ВидДанных = &ВидДанных И (";
	Счетчик = 0;
	Для Каждого Характеристика из Характеристики Цикл
		Если Счетчик > 0 Тогда
			Запрос.Текст = Запрос.Текст + " ИЛИ ";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + "(
		| ВЫРАЗИТЬ(ПоставляемыеДанныеХарактеристикиДанных.Значение КАК Строка(150)) = &Значение" + Счетчик + "
		| И ПоставляемыеДанныеХарактеристикиДанных.Характеристика = &Код" + Счетчик + ")";
		Запрос.УстановитьПараметр("Значение" + Счетчик, Характеристика.Значение);
		Запрос.УстановитьПараметр("Код" + Счетчик, Характеристика.Код);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	Запрос.Текст = Запрос.Текст + ")
	|СГРУППИРОВАТЬ ПО
	|	ПоставляемыеДанныеХарактеристикиДанных.Ссылка
	|ИМЕЮЩИЕ
	|Количество(*) = &Количество";
	Запрос.УстановитьПараметр("Количество", Счетчик);
	Запрос.УстановитьПараметр("ВидДанных", ВидДанных);
	Возврат Запрос;
	
КонецФункции

// Преобразование результатов выборки в XDTO объект
//
// Параметры
//  Выборка      - ВыборкаИзРезультатаЗапроса. Выборка запроса, содержащего информацию об
//                 обновлении данных 
//
Функция ПолучитьXDTOДескриптор(Выборка)
	Дескриптор = СоздатьОбъект(ФабрикаXDTO.Тип("http://www.1c.ru/SaaS/SuppliedData",
				"Descriptor"));
	Дескриптор.DataType = Выборка.КодВидаДанных;
	Дескриптор.CreationDate = Выборка.ДатаДобавления;
	Дескриптор.FileGUID = Выборка.ИдентификаторФайла;
	Дескриптор.Properties = СоздатьОбъект(ФабрикаXDTO.Тип("http://www.1c.ru/SaaS/SuppliedData",
				"ArrayOfProperty"));
	ВыборкаХарактеристик = Выборка.ХарактеристикиДанных.Выбрать();
	Пока ВыборкаХарактеристик.Следующий() Цикл
		Характеристика = СоздатьОбъект(ФабрикаXDTO.Тип("http://www.1c.ru/SaaS/SuppliedData",
				"Property"));
		Характеристика.Code = ВыборкаХарактеристик.ХарактеристикаКод;
		Характеристика.Value = ВыборкаХарактеристик.Значение;
		Характеристика.IsKey = Истина;
		Дескриптор.Properties.Property.Добавить(Характеристика);
	КонецЦикла; 
	Возврат Дескриптор;
	
КонецФункции

Функция ПолучитьДескриптор(Знач Выборка)
	Перем Дескриптор, ВыборкаХарактеристик, Характеристика;
	
	Дескриптор = Новый Структура("ВидДанных, ДатаДобавления, ИдентификаторФайла, Характеристики");
	Дескриптор.ВидДанных = Выборка.КодВидаДанных;
	Дескриптор.ДатаДобавления = Выборка.ДатаДобавления;
	Дескриптор.ИдентификаторФайла = Выборка.ИдентификаторФайла;
	Дескриптор.Характеристики = Новый Массив();
	
	ВыборкаХарактеристик = Выборка.ХарактеристикиДанных.Выбрать();
	Пока ВыборкаХарактеристик.Следующий() Цикл
		Характеристика = Новый Структура("Код, Значение, Ключевая");
		Характеристика.Код = ВыборкаХарактеристик.Характеристика;
		Характеристика.Значение = ВыборкаХарактеристик.Значение;
		Характеристика.Ключевая = Истина;
		Дескриптор.Характеристики.Добавить(Характеристика);
	КонецЦикла; 
	
	Возврат Дескриптор;
	
КонецФункции

Функция СоздатьОбъект(Знач ТипСообщения) Экспорт
	
	Возврат ФабрикаXDTO.Создать(ТипСообщения);
	
КонецФункции

Функция ТекстОшибкиПриПолученииФайла(Знач ИнформацияОбОшибке, Знач Файл)
	
	СообщениеОбОшибке = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
	
	Если Файл <> Неопределено Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |Ссылка на файл: ""%2"".'"),
			СообщениеОбОшибке,
			ПолучитьНавигационнуюСсылку(Файл) );
	КонецЕсли;
	
	Возврат СообщениеОбОшибке;
	
КонецФункции
